<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP中的垃圾回收机制]]></title>
    <url>%2F2018%2F07%2F31%2FPHP%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[引用计数前面有几篇文章提到，PHP中的变量都储存在’zval’这样一个容器中。在’zval’结构体中，存在is_ref和refcount两个元素分别来标志这个变量是否为引用集合（reference set）以及被引用的次数。我们很容易想到，既然refcount表示被引用的次数，那么当refcount=0的时候就表示没有变量指向这个zval容器，那么我们就可以将这个zval容器回收了。这就是引用计数垃圾回收机制。但是，这样可能会发生循环引用的问题，会造成内存泄露。1234567&lt;?php//step1$a = array( 'one' );$a[] =&amp; $a;//step2unset($a);?&gt; 创建一个数组类型变量$a，给变量$a新增一个元素，该元素为数组变量$a的一个引用。此时变量$a的refcount为2。 然后将数组a销毁，此时变量$a的refcount为1。尽管没有变量指向这个zval容器，它的引用计数依然为1，无法被垃圾回收，这样就会造成内存泄露。 回收周期(Collecting Cycles)自PHP5.3之后，使用引用计数系统中的同步周期回收(Concurrent Cycle Collection in Reference Counted Systems)这种方法来处理内存泄露问题。这个算法比较复杂，它的基本规则就是如果一个引用计数增加，它将继续被使用，当然就不再在垃圾中。如果引用计数减少到零，所在变量容器将被清除(free)。就是说，仅仅在引用计数减少到非零值时，才会产生垃圾周期(garbage cycle)。其次，在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。为避免不得不检查所有引用计数可能减少的垃圾周期，这个算法把所有可能根(possible roots 都是zval变量容器),放在根缓冲区(root buffer)中(用紫色来标记，称为疑似垃圾)，这样可以同时确保每个可能的垃圾根(possible garbage root)在缓冲区中只出现一次。仅仅在根缓冲区满了时，才对缓冲区内部所有不同的变量容器执行垃圾回收操作。看上图的步骤 A。 在步骤 B 中，模拟删除每个紫色变量。模拟删除时可能将不是紫色的普通变量引用数减”1”，如果某个普通变量引用计数变成0了，就对这个普通变量再做一次模拟删除。每个变量只能被模拟删除一次，模拟删除后标记为灰（原文说确保不会对同一个变量容器减两次”1”,不对的吧）。 在步骤 C 中，模拟恢复每个紫色变量。恢复是有条件的，当变量的引用计数大于0时才对其做模拟恢复。同样每个变量只能恢复一次，恢复后标记为黑，基本就是步骤 B 的逆运算。这样剩下的一堆没能恢复的就是该删除的蓝色节点了，在步骤 D 中遍历出来真的删除掉。 算法中都是模拟删除、模拟恢复、真的删除，都使用简单的遍历即可（最典型的深搜遍历）。复杂度为执行模拟操作的节点数正相关，不只是紫色的那些疑似垃圾变量。 以上的配图和步骤摘自PHP官方手册，估计大多数人也没看懂。我总结一下就是：对zval中的每一个元素的refcount进行-1操作，然后将减为0的元素模拟删除，如果此时zval的refcount变成了0，就说明仅仅只有它内部的元素指向了它自己，也就是发生了循环引用，这时候就可以将这个zval大胆的删掉了。 最后总结来看，PHP的GC机制有以下三点特性： 并不是每次refcount减少时都进入回收周期，只有根缓冲区满额后在开始垃圾回收。 可以解决循环引用问题。 可以总将内存泄露保持在一个阈值以下。 参考资料PHP手册：垃圾回收机制]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>垃圾回收</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP7中zval的变化]]></title>
    <url>%2F2018%2F07%2F07%2FPHP7%E4%B8%ADzval%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[背景前几天在研究PHP引用变量的时候敲测试代码发现了一个很神奇的现象。在使用Xdebug扩展中的xdebug_debug_zval()函数查看变量的引用计数refcount的时候，发现PHP7和PHP5.4输出的结果竟然不一样，而且PHP7中输出的refcount竟然是0。具体测试代码和输出结果如下：1234echo 'Version: '.PHP_VERSION.PHP_EOL;$a = 'Hello World';debug_zval_dump($a);xdebug_debug_zval('a'); PHP5.6输出： Version: 5.6.27string(11) “Hello World” refcount(2)a: (refcount=1, is_ref=0)=’Hello World’ PHP7.0输出： Version: 7.0.12string(11) “Hello World” refcount(1)a: (refcount=0, is_ref=0)=’Hello World’ 解决问题经过坚持不懈的查找相关资料，终于在万能的stackoverflow中找到nikic大佬关于这个问题的回答，回答如下:In PHP 7 a zval can be reference counted or not. There is a flag in the zval structure which determined this. There are some types which are never refcounted. These types are null, bool, int and double. There are other types which are always refcounted. These are objects, resources and references. And then there are types, which are sometimes refcounted. Those are strings and arrays. For strings the not-refcounted variant is called an “interned string”. If you’re using an NTS (not thread-safe) PHP 7 build, which you typically are, all string literals in your code will be interned. These interned strings are deduplicated (i.e. there is only one interned string with a certain content) and are guaranteed to exist for the full duration of the request, so there is no need to use reference counting for them. If you use opcache, these strings will live in shared memory, in which case you can’t use reference counting for them (as our refcounting mechanism is non-atomic). Interned strings have a dummy refcount of 1, which is what you’re seeing here. For arrays the not-refcounted variant is called an “immutable array”. If you use opcache, then constant array literals in your code will be converted into immutable arrays. Once again, these live in shared memory and as such must not use refcounting. Immutable arrays have a dummy refcount of 2, as it allows us to optimize certain separation paths. 原谅我用蹩脚的英语水平翻译一下：在PHP7中，zval结构体中有一个标志来决定zval是否能被引用计数。像null,bool,int,double这些变量类型永远不会被引用计数（这个地方可能有些不太严谨，鸟哥的博客中写道PHP7中zval的类型共有18种，其中IS_LONG,IS_DOUBLE,IS_NULL,IS_FALSE,IS_TRUE不会使用引用计数）。像object,resources,references这些变量类型总是会使用引用计数。然而，像array，strings这些变量类型有时会使用引用计数，有时则不会。不使用引用计数的字符串类型被叫做“interned string（保留字符串）”。如果你使用一个NTS(非线程安全)的PHP7来构建，通常情况下，代码中的所有字符串文字都将是限定的。这些保留字符串都是不可重复的（即，只会存在一个含有特定内容的保留字符串）。它会一直存在直到请求结束时才销毁，所以也就无需进行引用计数。如果使用了 opcache 的话，保留字符会被存储在共享内存中，在这种情况下，无法使用引用计数（因为我们引用计数的机制是非原子的）。保留字符串的伪引用计数为1。对于数组来说，无引用计数的变量称为“不可变数组”。如果使用opcache，则代码中的常量数组文字将转换为不可变数组。同样的，他们存在于共享内存中，因此不得使用引用计数。不可变数组的伪引用数为2，因为它允许我们优化某些分离路径。另外，关于PHP7中zval变化更加详细的阐述请看我转载的两篇博文：【转】变量在PHP7内部的实现（一）【转】变量在PHP7内部的实现（一）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]变量在PHP7内部的实现（二）]]></title>
    <url>%2F2018%2F07%2F06%2F%E8%BD%AC-%E5%8F%98%E9%87%8F%E5%9C%A8PHP7%E5%86%85%E9%83%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的博客。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。 要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。 第一部分讲了 PHP5 和 PHP7 中关于变量最基础的实现和变化。这里再重复一下，主要的变化就是 zval 不再单独分配内存，不自己存储引用计数。整型浮点型等简单类型直接存储在 zval 中。复杂类型则通过指针指向一个独立的结构体。 复杂的 zval 数据值有一个共同的头，其结构由 zend_refcounted 定义： 123456789101112struct _zend_refcounted &#123; uint32_t refcount; union &#123; struct &#123; ZEND_ENDIAN_LOHI_3( zend_uchar type, zend_uchar flags, uint16_t gc_info) &#125; v; uint32_t type_info; &#125; u;&#125;; 这个头存储有 refcount（引用计数），值的类型 type 和循环回收的相关信息 gc_info 以及类型标志位 flags。 接下来会对每种复杂类型的实现单独进行分析并和 PHP5 的实现进行比较。引用虽然也属于复杂类型，但是上一部分已经介绍过了，这里就不再赘述。另外这里也不会讲到资源类型（因为作者觉得资源类型没什么好讲的）。 字符串PHP7 中定义了一个新的结构体 zend_string 用于存储字符串变量： 123456struct _zend_string &#123; zend_refcounted gc; zend_ulong h; /* hash value */ size_t len; char val[1];&#125;; 除了引用计数的头以外，字符串还包含哈希缓存 h，字符串长度 len 以及字符串的值 val。哈希缓存的存在是为了防止使用字符串做为 hashtable 的 key 在查找时需要重复计算其哈希值，所以这个在使用之前就对其进行初始化。 如果你对 C 语言了解的不是很深入的话，可能会觉得 val 的定义有些奇怪：这个声明只有一个元素，但是显然我们想存储的字符串长度肯定大于一个字符的长度。这里其实使用的是结构体的一个『黑』方法：在声明数组时只定义一个元素，但是实际创建 zend_string 时再分配足够的内存来存储整个字符串。这样我们还是可以通过 val 访问完整的字符串。 当然这属于非常规的实现手段，因为我们实际的读和写的内容都超过了单字符数组的边界。但是 C 语言编译器却不知道你是这么做的。虽然 C99 也曾明确规定过支持『柔性数组』，但是感谢我们的好朋友微软，没人能在不同的平台上保证 C99 的一致性（所以这种手段是为了解决 Windows 平台下柔性数组的支持问题）。 新的字符串类型的结构比原生的 C 字符串更方便使用：第一是因为直接存储了字符串的长度，这样就不用每次使用时都去计算。第二是字符串也有引用计数的头，这样也就可以在不同的地方共享字符串本身而无需使用 zval。一个经常使用的地方就是共享 hashtable 的 key。 但是新的字符串类型也有一个很不好的地方：虽然可以很方便的从 zend_string 中取出 C 字符串（使用 str-&gt;val 即可），但反过来，如果将 C 字符串变成 zend_string 就需要先分配 zend_string 需要的内存，再将字符串复制到 zend_string 中。这在实际使用的过程中并不是很方便。 字符串也有一些特有的标志（存储在 GC 的标志位中的）： 123#define IS_STR_PERSISTENT (1&lt;&lt;0) /* allocated using malloc */#define IS_STR_INTERNED (1&lt;&lt;1) /* interned string */#define IS_STR_PERMANENT (1&lt;&lt;2) /* interned string surviving request boundary */ 持久化的字符串需要的内存直接从系统本身分配而不是 zend 内存管理器（ZMM），这样它就可以一直存在而不是只在单次请求中有效。给这种特殊的分配打上标记便于 zval 使用持久化字符串。在 PHP5 中并不是这样处理的，是在使用前复制一份到 ZMM 中。 保留字符（interned strings）有点特殊，它会一直存在直到请求结束时才销毁，所以也就无需进行引用计数。保留字符串也不可重复（duplicate），所以在创建新的保留字符时也会先检查是否有同样字符的已经存在。所有 PHP 源码中不可变的字符串都是保留字符（包括字符串常量、变量名函数名等）。持久化字符串也是请求开始之前已经创建好的保留字符。但普通的保留字符在请求结束后会销毁，持久化字符串却始终存在。 如果使用了 opcache 的话保留字符会被存储在共享内存（SHM）中这样就可以在所有 PHP 进程质检共享。这种情况下持久化字符串也就没有存在的意义了，因为保留字符也是不会被销毁的。 数组因为之前的文章有讲过新的数组实现，所以这里就不再详细描述了。虽然最近有些变化导致之前的描述不是十分准确了，但是基本的概念还是一致的。 这里要说的是之前的文章中没有提到的数组相关的概念：不可变数组。其本质上和保留字符类似：没有引用计数且在请求结束之前一直存在（也可能在请求结束之后还存在）。 因为某些内存管理方便的原因，不可变数组只会在开启 opcache 时会使用到。我们来看看实际使用的例子，先看以下的脚本： 12345&lt;?phpfor ($i = 0; $i &lt; 1000000; ++$i) &#123; $array[] = ['foo'];&#125;var_dump(memory_get_usage()); 开启 opcache 时，以上代码会使用 32MB 的内存，不开启的情况下因为 $array 每个元素都会复制一份 [&#39;foo&#39;] ，所以需要 390MB。这里会进行完整的复制而不是增加引用计数值的原因是防止 zend 虚拟机操作符执行的时候出现共享内存出错的情况。我希望不使用 opcache 时内存暴增的问题以后能得到改善。 PHP5 中的对象在了解 PHP7 中的对象实现直线我们先看一下 PHP5 的并且看一下有什么效率上的问题。PHP5 中的 zval 会存储一个 zend_object_value 结构，其定义如下： 1234typedef struct _zend_object_value &#123; zend_object_handle handle; const zend_object_handlers *handlers;&#125; zend_object_value; handle 是对象的唯一 ID，可以用于查找对象数据。handles 是保存对象各种属性方法的虚函数表指针。通常情况下 PHP 对象都有着同样的 handler 表，但是 PHP 扩展创建的对象也可以通过操作符重载等方式对其行为自定义。 对象句柄（handler）是作为索引用于『对象存储』，对象存储本身是一个存储容器（bucket）的数组，bucket 定义如下： 12345678910111213141516171819typedef struct _zend_object_store_bucket &#123; zend_bool destructor_called; zend_bool valid; zend_uchar apply_count; union _store_bucket &#123; struct _store_object &#123; void *object; zend_objects_store_dtor_t dtor; zend_objects_free_object_storage_t free_storage; zend_objects_store_clone_t clone; const zend_object_handlers *handlers; zend_uint refcount; gc_root_buffer *buffered; &#125; obj; struct &#123; int next; &#125; free_list; &#125; bucket;&#125; zend_object_store_bucket; 这个结构体包含了很多东西。前三个成员只是些普通的元数据（对象的析构函数是否被调用过、bucke 是否被使用过以及对象被递归调用过多少次）。接下来的联合体用于区分 bucket 是处于使用中的状态还是空闲状态。上面的结构中最重要的是 struct _store_object 子结构体： 第一个成员 object 是指向实际对象（也就是对象最终存储的位置）的指针。对象实际并不是直接嵌入到对象存储的 bucket 中的，因为对象不是定长的。对象指针下面是三个用于管理对象销毁、释放与克隆的操作句柄（handler）。这里要注意的是 PHP 销毁和释放对象是不同的步骤，前者在某些情况下有可能会被跳过（不完全释放）。克隆操作实际上几乎几乎不会被用到，因为这里包含的操作不是普通对象本身的一部分，所以（任何时候）他们在每个对象中他们都会被单独复制（duplicate）一份而不是共享。 这些对象存储操作句柄后面是一个普通的对象 handlers 指针。存储这几个数据是因为有时候可能会在 zval 未知的情况下销毁对象（通常情况下这些操作都是针对 zval 进行的）。 bucket 也包含了 refcount 的字段，不过这种行为在 PHP5 中显得有些奇怪，因为 zval 本身已经存储了引用计数。为什么还需要一个多余的计数呢？问题在于虽然通常情况下 zval 的『复制』行为都是简单的增加引用计数即可，但是偶尔也会有深度复制的情况出现，比如创建一个全新的 zval 但是保存同样的 zend_object_value。这种情况下两个不同的 zval 就用到了同一个对象存储的 bucket，所以 bucket 自身也需要进行引用计数。这种『双重计数』的方式是 PHP5 的实现内在的问题。GC 根缓冲区中的 buffered 指针也是由于同样的原因才需要进行完全复制（duplicate）。 现在看看对象存储中指针指向的实际的 object 的结构，通常情况下用户层面的对象定义如下： 123456typedef struct _zend_object &#123; zend_class_entry *ce; HashTable *properties; zval **properties_table; HashTable *guards;&#125; zend_object; zend_class_entry 指针指向的是对象实现的类原型。接下来的两个元素是使用不同的方式存储对象属性。动态属性（运行时添加的而不是在类中定义的）全部存在 properties 中，不过只是属性名和值的简单匹配。 不过这里有针对已经声明的属性的一个优化：编译期间每个属性都会被指定一个索引并且属性本身是存储在 properties_table 的索引中。属性名称和索引的匹配存储在类原型的 hashtable 中。这样就可以防止每个对象使用的内存超过 hashtable 的上限，并且属性的索引会在运行时有多处缓存。 guards 的哈希表是用于实现魔术方法的递归行为的，比如 __get，这里我们不深入讨论。 除了上文提到过的双重计数的问题，这种实现还有一个问题是一个最小的只有一个属性的对象也需要 136 个字节的内存（这还不算 zval 需要的内存）。而且中间存在很多间接访问动作：比如要从对象 zval 中取出一个元素，先需要取出对象存储 bucket，然后是 zend object，然后才能通过指针找到对象属性表和 zval。这样这里至少就有 4 层间接访问（并且实际使用中可能最少需要七层）。 PHP7 中的对象PHP7 的实现中试图解决上面这些问题，包括去掉双重引用计数、减少内存使用以及间接访问。新的 zend_object 结构体如下： 12345678struct _zend_object &#123; zend_refcounted gc; uint32_t handle; zend_class_entry *ce; const zend_object_handlers *handlers; HashTable *properties; zval properties_table[1];&#125;; 可以看到现在这个结构体几乎就是一个对象的全部内容了：zend_object_value 已经被替换成一个直接指向对象和对象存储的指针，虽然没有完全移除，但已经是很大的提升了。 除了 PHP7 中惯用的 zend_refcounted 头以外，handle 和 对象的 handlers 现在也被放到了 zend_object 中。这里的 properties_table 同样用到了 C 结构体的小技巧，这样 zend_object 和属性表就会得到一整块内存。当然，现在属性表是直接嵌入到 zval 中的而不是指针。 现在对象结构体中没有了 guards 表，现在如果需要的话这个字段的值会被存储在 properties_table 的第一位中，也就是使用 __get 等方法的时候。不过如果没有使用魔术方法的话，guards 表会被省略。 dtor、free_storage 和 clone 三个操作句柄之前是存储在对象操作 bucket 中，现在直接存在 handlers 表中，其结构体定义如下： 12345678910struct _zend_object_handlers &#123; /* offset of real object header (usually zero) */ int offset; /* general object functions */ zend_object_free_obj_t free_obj; zend_object_dtor_obj_t dtor_obj; zend_object_clone_obj_t clone_obj; /* individual object functions */ // ... rest is about the same in PHP 5&#125;; handler 表的第一个成员是 offset，很显然这不是一个操作句柄。这个 offset 是现在的实现中必须存在的，因为虽然内部的对象总是嵌入到标准的 zend_object 中，但是也总会有添加一些成员进去的需求。在 PHP5 中解决这个问题的方法是添加一些内容到标准的对象后面： 12345struct custom_object &#123; zend_object std; uint32_t something; // ...&#125;; 这样如果你可以轻易的将 zend_object* 添加到 struct custom_object* 中。这也是 C 语言中常用的结构体继承的做法。但是在 PHP7 中这种实现会有一个问题：因为 zend_object 在存储属性表时用了结构体 hack 的技巧，zend_object 尾部存储的 PHP 属性会覆盖掉后续添加进去的内部成员。所以 PHP7 的实现中会把自己添加的成员添加到标准对象结构的前面： 12345struct custom_object &#123; uint32_t something; // ... zend_object std;&#125;; 不过这样也就意味着现在无法直接在 zend_object* 和 struct custom_object* 进行简单的转换了，因为两者都一个偏移分割开了。所以这个偏移量就需要被存储在对象 handler 表中的第一个元素中，这样在编译时通过 offsetof() 宏就能确定具体的偏移值。 也许你会好奇既然现在已经直接（在 zend_value 中）存储了 zend_object 的指针，那现在就不需要再到对象存储中去查找对象了，为什么 PHP7 的对象者还保留着 handle 字段呢？ 这是因为现在对象存储仍然存在，虽然得到了极大的简化，所以保留 handle 仍然是有必要的。现在它只是一个指向对象的指针数组。当对象被创建时，会有一个指针插入到对象存储中并且其索引会保存在 handle 中，当对象被释放时，索引也会被移除。 那么为什么现在还需要对象存储呢？因为在请求结束的阶段会在存在某个节点，在这之后再去执行用户代码并且取指针数据时就不安全了。为了避免这种情况出现 PHP 会在更早的节点上执行所有对象的析构函数并且之后就不再有此类操作，所以就需要一个活跃对象的列表。 并且 handle 对于调试也是很有用的，它让每个对象都有了一个唯一的 ID，这样就很容易区分两个对象是同一个还是只是有相同的内容。虽然 HHVM 没有对象存储的概念，但它也存了对象的 handle。 和 PHP5 相比，现在的实现中只有一个引用计数（zval 自身不计数），并且内存的使用量有了很大的缩减：40 个字节用于基础对象，每个属性需要 16 个字节，并且这还是算了 zval 之后的。间接访问的情况也有了显著的改善，因为现在中间层的结构体要么被去掉了，要么就是直接嵌入的，所以现在读取一个属性只有一层访问而不再是四层。 间接 zval到现在我们已经基本提到过了所有正常的 zval 类型，但是也有一对特殊类型用于某些特定的情况的，其中之一就是 PHP7 新添加的 IS_INDIRECT。 间接 zval 指的就是其真正的值是存储在其他地方的。注意这个 IS_REFERENCE 类型是不同的，间接 zval 是直接指向另外一个 zval 而不是像 zend_reference 结构体一样嵌入 zval。 为了理解在什么时候会出现这种情况，我们来看一下 PHP 中变量的实现（实际上对象属性的存储也是一样的情况）。 所有在编译过程中已知的变量都会被指定一个索引并且其值会被存在编译变量（CV）表的相应位置中。但是 PHP 也允许你动态的引用变量，不管是局部变量还是全局变量（比如 $GLOBALS），只要出现这种情况，PHP 就会为脚本或者函数创建一个符号表，这其中包含了变量名和它们的值之间的映射关系。 但是问题在于：怎么样才能实现两个表的同时访问呢？我们需要在 CV 表中能够访问普通变量，也需要能在符号表中访问编译变量。在 PHP5 中 CV 表用了双重指针 zval**，通常这些指针指向中间的 zval* 的表，zval* 最终指向的才是实际的 zval: 1234567+------ CV_ptr_ptr[0]| +---- CV_ptr_ptr[1]| | +-- CV_ptr_ptr[2]| | || | +-&gt; CV_ptr[0] --&gt; some zval| +---&gt; CV_ptr[1] --&gt; some zval+-----&gt; CV_ptr[2] --&gt; some zval 当需要使用符号表时存储 zval* 的中间表其实是没有用到的而 zval** 指针会被更新到 hashtable buckets 的响应位置中。我们假定有 $a、$b 和 $c 三个变量，下面是简单的示意图： 123CV_ptr_ptr[0] --&gt; SymbolTable[&quot;a&quot;].pDataPtr --&gt; some zvalCV_ptr_ptr[1] --&gt; SymbolTable[&quot;b&quot;].pDataPtr --&gt; some zvalCV_ptr_ptr[2] --&gt; SymbolTable[&quot;c&quot;].pDataPtr --&gt; some zval 但是 PHP7 的用法中已经没有这个问题了，因为 PHP7 中的 hashtable 大小发生变化时 hashtable bucket 就失效了。所以 PHP7 用了一个相反的策略：为了访问 CV 表中存储的变量，符号表中存储 INDIRECT 来指向 CV 表。CV 表在符号表的生命周期内不会重新分配，所以也就不会存在有无效指针的问题了。 所以加入你有一个函数并且在 CV 表中有 $a、$b 和 $c，同时还有一个动态分配的变量 $d，符号表的结构看起来大概就是这个样子： 1234SymbolTable[&quot;a&quot;].value = INDIRECT --&gt; CV[0] = LONG 42SymbolTable[&quot;b&quot;].value = INDIRECT --&gt; CV[1] = DOUBLE 42.0SymbolTable[&quot;c&quot;].value = INDIRECT --&gt; CV[2] = STRING --&gt; zend_string(&quot;42&quot;)SymbolTable[&quot;d&quot;].value = ARRAY --&gt; zend_array([4, 2]) 间接 zval 也可以是一个指向 IS_UNDEF 类型 zval 的指针，当 hashtable 没有和它关联的 key 时就会出现这种情况。所以当使用 unset($a) 将 CV[0] 的类型标记为 UNDEF 时就会判定符号表不存在键值为 a 的数据。 常量和 AST还有两个需要说一下的在 PHP5 和 PHP7 中都存在的特殊类型 IS_CONSTANT 和 IS_CONSTANT_AST。要了解他们我们还是先看以下的例子： 12345678&lt;?phpfunction test($a = ANSWER, $b = ANSWER * ANSWER) &#123; return $a + $b;&#125;define('ANSWER', 42);var_dump(test()); // int(42 + 42 * 42)· test() 函数的两个参数的默认值都是由常量 ANSWER构成，但是函数声明时常量的值尚未定义。常量的具体值只有通过 define() 定义时才知道。 由于以上问题的存在，参数和属性的默认值、常量以及其他接受『静态表达式』的东西都支持『延时绑定』直到首次使用时。 常量（或者类的静态属性）这些需要『延时绑定』的数据就是最常需要用到 IS_CONSTANT 类型 zval 的地方。如果这个值是表达式，就会使用 IS_CONSTANT_AST 类型的 zval 指向表达式的抽象语法树（AST）。 到这里我们就结束了对 PHP7 中变量实现的分析。后面我可能还会写两篇文章来介绍一些虚拟机优化、新的命名约定以及一些编译器基础结构的优化的内容（这是作者原话）。 译者注：两篇文章篇幅较长，翻译中可能有疏漏或不正确的地方，如果发现了请及时指正。 文章转自Scholer’s Blog - [译]变量在 PHP7 内部的实现（二）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]变量在 PHP7 内部的实现（一）]]></title>
    <url>%2F2018%2F07%2F06%2F%E8%BD%AC-%E5%8F%98%E9%87%8F%E5%9C%A8PHP7%E5%86%85%E9%83%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的博客。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。 要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。 由于大量的细节描述，本文将会分成两个部分：第一部分主要描述 zval(zend value) 的实现在 PHP5 和 PHP7 中有何不同以及引用的实现。第二部分将会分析单独类型（strings、objects）的细节。 PHP5 中的 zvalPHP5 中 zval 结构体定义如下： 123456typedef struct _zval_struct &#123; zvalue_value value; zend_uint refcount__gc; zend_uchar type; zend_uchar is_ref__gc;&#125; zval; 如上，zval 包含一个 value、一个 type 以及两个 __gc 后缀的字段。value 是个联合体，用于存储不同类型的值： 1234567891011typedef union _zvalue_value &#123; long lval; // 用于 bool 类型、整型和资源类型 double dval; // 用于浮点类型 struct &#123; // 用于字符串 char *val; int len; &#125; str; HashTable *ht; // 用于数组 zend_object_value obj; // 用于对象 zend_ast *ast; // 用于常量表达式(PHP5.6 才有)&#125; zvalue_value; C 语言联合体的特征是一次只有一个成员是有效的并且分配的内存与需要内存最多的成员匹配（也要考虑内存对齐）。所有成员都存储在内存的同一个位置，根据需要存储不同的值。当你需要 lval 的时候，它存储的是有符号整形，需要 dval 时，会存储双精度浮点数。 需要指出的是是联合体中当前存储的数据类型会记录到 type 字段，用一个整型来标记： 123456789101112#define IS_NULL 0 /* Doesn't use value */#define IS_LONG 1 /* Uses lval */#define IS_DOUBLE 2 /* Uses dval */#define IS_BOOL 3 /* Uses lval with values 0 and 1 */#define IS_ARRAY 4 /* Uses ht */#define IS_OBJECT 5 /* Uses obj */#define IS_STRING 6 /* Uses str */#define IS_RESOURCE 7 /* Uses lval, which is the resource ID *//* Special types used for late-binding of constants */#define IS_CONSTANT 8#define IS_CONSTANT_AST 9 PHP5 中的引用计数在PHP5中，zval 的内存是单独从堆（heap）中分配的（有少数例外情况），PHP 需要知道哪些 zval 是正在使用的，哪些是需要释放的。所以这就需要用到引用计数：zval 中 refcount__gc 的值用于保存 zval 本身被引用的次数，比如 $a = $b = 42 语句中，42 被两个变量引用，所以它的引用计数就是 2。如果引用计数变成 0，就意味着这个变量已经没有用了，内存也就可以释放了。 注意这里提及到的引用计数指的不是 PHP 代码中的引用（使用 &amp;），而是变量的使用次数。后面两者需要同时出现时会使用『PHP 引用』和『引用』来区分两个概念，这里先忽略掉 PHP 的部分。 一个和引用计数紧密相关的概念是『写时复制』：对于多个引用来说，zaval 只有在没有变化的情况下才是共享的，一旦其中一个引用改变 zval 的值，就需要复制（”separated”）一份 zval，然后修改复制后的 zval。 下面是一个关于『写时复制』和 zval 的销毁的例子： 1234567891011121314&lt;?php$a = 42; // $a -&gt; zval_1(type=IS_LONG, value=42, refcount=1)$b = $a; // $a, $b -&gt; zval_1(type=IS_LONG, value=42, refcount=2)$c = $b; // $a, $b, $c -&gt; zval_1(type=IS_LONG, value=42, refcount=3)// 下面几行是关于 zval 分离的$a += 1; // $b, $c -&gt; zval_1(type=IS_LONG, value=42, refcount=2) // $a -&gt; zval_2(type=IS_LONG, value=43, refcount=1)unset($b); // $c -&gt; zval_1(type=IS_LONG, value=42, refcount=1) // $a -&gt; zval_2(type=IS_LONG, value=43, refcount=1)unset($c); // zval_1 is destroyed, because refcount=0 // $a -&gt; zval_2(type=IS_LONG, value=43, refcount=1) 引用计数有个致命的问题：无法检查并释放循环引用（使用的内存）。为了解决这问题，PHP 使用了循环回收的方法。当一个 zval 的计数减一时，就有可能属于循环的一部分，这时将 zval 写入到『根缓冲区』中。当缓冲区满时，潜在的循环会被打上标记并进行回收。 因为要支持循环回收，实际使用的 zval 的结构实际上如下： 1234567typedef struct _zval_gc_info &#123; zval z; union &#123; gc_root_buffer *buffered; struct _zval_gc_info *next; &#125; u;&#125; zval_gc_info; zval_gc_info 结构体中嵌入了一个正常的 zval 结构，同时也增加了两个指针参数，但是共属于同一个联合体 u，所以实际使用中只有一个指针是有用的。buffered 指针用于存储 zval 在根缓冲区的引用地址，所以如果在循环回收执行之前 zval 已经被销毁了，这个字段就可能被移除了。next 在回收销毁值的时候使用，这里不会深入。 修改动机下面说说关于内存使用上的情况，这里说的都是指在 64 位的系统上。首先，由于 str 和 obj 占用的大小一样， zvalue_value 这个联合体占用 16 个字节（bytes）的内存。整个 zval 结构体占用的内存是 24 个字节（考虑到内存对齐），zval_gc_info 的大小是 32 个字节。综上，在堆（相对于栈）分配给 zval 的内存需要额外的 16 个字节，所以每个 zval 在不同的地方一共需要用到 48 个字节（要理解上面的计算方式需要注意每个指针在 64 位的系统上也需要占用 8 个字节）。 在这点上不管从什么方面去考虑都可以认为 zval 的这种设计效率是很低的。比如 zval 在存储整型的时候本身只需要 8 个字节，即使考虑到需要存一些附加信息以及内存对齐，额外 8 个字节应该也是足够的。 在存储整型时本来确实需要 16 个字节，但是实际上还有 16 个字节用于引用计数、16 个字节用于循环回收。所以说 zval 的内存分配和释放都是消耗很大的操作，我们有必要对其进行优化。 从这个角度思考：一个整型数据真的需要存储引用计数、循环回收的信息并且单独在堆上分配内存吗？答案是当然不，这种处理方式一点都不好。 这里总结一下 PHP5 中 zval 实现方式存在的主要问题： zval 总是单独从堆中分配内存； zval 总是存储引用计数和循环回收的信息，即使是整型这种可能并不需要此类信息的数据； 在使用对象或者资源时，直接引用会导致两次计数（原因会在下一部分讲）； 某些间接访问需要一个更好的处理方式。比如现在访问存储在变量中的对象间接使用了四个指针（指针链的长度为四）。这个问题也放到下一部分讨论； 直接计数也就意味着数值只能在 zval 之间共享。如果想在 zval 和 hashtable key 之间共享一个字符串就不行（除非 hashtable key 也是 zval）。 PHP7 中的 zval在 PHP7 中 zval 有了新的实现方式。最基础的变化就是 zval 需要的内存不再是单独从堆上分配，不再自己存储引用计数。复杂数据类型（比如字符串、数组和对象）的引用计数由其自身来存储。这种实现方式有以下好处： 简单数据类型不需要单独分配内存，也不需要计数； 不会再有两次计数的情况。在对象中，只有对象自身存储的计数是有效的； 由于现在计数由数值自身存储，所以也就可以和非 zval 结构的数据共享，比如 zval 和 hashtable key 之间； 间接访问需要的指针数减少了。 我们看看现在 zval 结构体的定义（现在在 zend_types.h 文件中）： 12345678910111213141516171819202122struct _zval_struct &#123; zend_value value; /* value */ union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar type, /* active type */ zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved) /* call info for EX(This) */ &#125; v; uint32_t type_info; &#125; u1; union &#123; uint32_t var_flags; uint32_t next; /* hash collision chain */ uint32_t cache_slot; /* literal cache slot */ uint32_t lineno; /* line number (for ast nodes) */ uint32_t num_args; /* arguments number for EX(This) */ uint32_t fe_pos; /* foreach position */ uint32_t fe_iter_idx; /* foreach iterator index */ &#125; u2;&#125;; 结构体的第一个元素没太大变化，仍然是一个 value 联合体。第二个成员是由一个表示类型信息的整型和一个包含四个字符变量的结构体组成的联合体（可以忽略 ZEND_ENDIAN_LOHI_4 宏，它只是用来解决跨平台大小端问题的）。这个子结构中比较重要的部分是 type（和以前类似）和 type_flags，这个接下来会解释。 上面这个地方也有一点小问题：value 本来应该占 8 个字节，但是由于内存对齐，哪怕只增加一个字节，实际上也是占用 16 个字节（使用一个字节就意味着需要额外的 8 个字节）。但是显然我们并不需要 8 个字节来存储一个 type 字段，所以我们在 u1 的后面增加了了一个名为 u2 的联合体。默认情况下是用不到的，需要使用的时候可以用来存储 4 个字节的数据。这个联合体可以满足不同场景下的需求。 PHP7 中 value 的结构定义如下： 12345678910111213141516171819typedef union _zend_value &#123; zend_long lval; /* long value */ double dval; /* double value */ zend_refcounted *counted; zend_string *str; zend_array *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; zval *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct &#123; uint32_t w1; uint32_t w2; &#125; ww;&#125; zend_value; 首先需要注意的是现在 value 联合体需要的内存是 8 个字节而不是 16。它只会直接存储整型（lval）或者浮点型（dval）数据，其他情况下都是指针（上面提到过，指针占用 8 个字节，最下面的结构体由两个 4 字节的无符号整型组成）。上面所有的指针类型（除了特殊标记的）都有一个同样的头（zend_refcounted）用来存储引用计数： 123456789101112typedef struct _zend_refcounted_h &#123; uint32_t refcount; /* reference counter 32-bit */ union &#123; struct &#123; ZEND_ENDIAN_LOHI_3( zend_uchar type, zend_uchar flags, /* used for strings &amp; objects */ uint16_t gc_info) /* keeps GC root number (or 0) and color */ &#125; v; uint32_t type_info; &#125; u;&#125; zend_refcounted_h; 现在，这个结构体肯定会包含一个存储引用计数的字段。除此之外还有 type、flags 和 gc_info。type 存储的和 zval 中的 type 相同的内容，这样 GC 在不存储 zval 的情况下单独使用引用计数。flags 在不同的数据类型中有不同的用途，这个放到下一部分讲。 gc_info 和 PHP5 中的 buffered 作用相同，不过不再是位于根缓冲区的指针，而是一个索引数字。因为以前根缓冲区的大小是固定的（10000 个元素），所以使用一个 16 位（2 字节）的数字代替 64 位（8 字节）的指针足够了。gc_info 中同样包含一个『颜色』位用于回收时标记结点。 zval 内存管理上文提到过 zval 需要的内存不再单独从堆上分配。但是显然总要有地方来存储它，所以会存在哪里呢？实际上大多时候它还是位于堆中（所以前文中提到的地方重点不是堆，而是单独分配），只不过是嵌入到其他的数据结构中的，比如 hashtable 和 bucket 现在就会直接有一个 zval 字段而不是指针。所以函数表编译变量和对象属性在存储时会是一个 zval 数组并得到一整块内存而不是散落在各处的 zval 指针。之前的 zval * 现在都变成了 zval。 之前当 zval 在一个新的地方使用时会复制一份 zval * 并增加一次引用计数。现在就直接复制 zval 的值（忽略 u2），某些情况下可能会增加其结构指针指向的引用计数（如果在进行计数）。 那么 PHP 怎么知道 zval 是否正在计数呢？不是所有的数据类型都能知道，因为有些类型（比如字符串或数组）并不是总需要进行引用计数。所以 type_info 字段就是用来记录 zval 是否在进行计数的，这个字段的值有以下几种情况： 123456#define IS_TYPE_CONSTANT (1&lt;&lt;0) /* special */#define IS_TYPE_IMMUTABLE (1&lt;&lt;1) /* special */#define IS_TYPE_REFCOUNTED (1&lt;&lt;2)#define IS_TYPE_COLLECTABLE (1&lt;&lt;3)#define IS_TYPE_COPYABLE (1&lt;&lt;4)#define IS_TYPE_SYMBOLTABLE (1&lt;&lt;5) /* special */ 注：在 7.0.0 的正式版本中，上面这一段宏定义的注释这几个宏是供 zval.u1.v.type_flags 使用的。这应该是注释的错误，因为这个上述字段是 zend_uchar 类型。 type_info 的三个主要的属性就是『可计数』（refcounted）、『可回收』（collectable）和『可复制』（copyable）。计数的问题上面已经提过了。『可回收』用于标记 zval 是否参与循环，不如字符串通常是可计数的，但是你却没办法给字符串制造一个循环引用的情况。 是否可复制用于表示在复制时是否需要在复制时制造（原文用的 “duplication” 来表述，用中文表达出来可能不是很好理解）一份一模一样的实体。”duplication” 属于深度复制，比如在复制数组时，不仅仅是简单增加数组的引用计数，而是制造一份全新值一样的数组。但是某些类型（比如对象和资源）即使 “duplication” 也只能是增加引用计数，这种就属于不可复制的类型。这也和对象和资源现有的语义匹配（现有，PHP7 也是这样，不单是 PHP5）。 下面的表格上标明了不同的类型会使用哪些标记（x 标记的都是有的特性）。『简单类型』（simple types）指的是整型或布尔类型这些不使用指针指向一个结构体的类型。下表中也有『不可变』（immutable）的标记，它用来标记不可变数组的，这个在下一部分再详述。 interned string（保留字符）在这之前没有提过，其实就是函数名、变量名等无需计数、不可重复的字符串。 12345678910 | refcounted | collectable | copyable | immutable----------------+------------+-------------+----------+----------simple types | | | |string | x | | x |interned string | | | |array | x | x | x |immutable array | | | | xobject | x | x | |resource | x | | |reference | x | | | 要理解这一点，我们可以来看几个例子，这样可以更好的认识 zval 内存管理是怎么工作的。 下面是整数行为模式，在上文中 PHP5 的例子的基础上进行了一些简化 ： 1234567891011&lt;?php$a = 42; // $a = zval_1(type=IS_LONG, value=42)$b = $a; // $a = zval_1(type=IS_LONG, value=42) // $b = zval_2(type=IS_LONG, value=42)$a += 1; // $a = zval_1(type=IS_LONG, value=43) // $b = zval_2(type=IS_LONG, value=42)unset($a); // $a = zval_1(type=IS_UNDEF) // $b = zval_2(type=IS_LONG, value=42) 这个过程其实挺简单的。现在整数不再是共享的，变量直接就会分离成两个单独的 zval，由于现在 zval 是内嵌的所以也不需要单独分配内存，所以这里的注释中使用 = 来表示的而不是指针符号 -&gt;，unset 时变量会被标记为 IS_UNDEF。下面看一下更复杂的情况： 123456789101112&lt;?php$a = []; // $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])$b = $a; // $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=2, value=[]) // $b = zval_2(type=IS_ARRAY) ---^// zval 分离在这里进行$a[] = 1 // $a = zval_1(type=IS_ARRAY) -&gt; zend_array_2(refcount=1, value=[1]) // $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])unset($a); // $a = zval_1(type=IS_UNDEF), zend_array_2 被销毁 // $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[]) 这种情况下每个变量变量有一个单独的 zval，但是是指向同一个（有引用计数） zend_array 的结构体。修改其中一个数组的值时才会进行复制。这点和 PHP5 的情况类似。 类型（Types）我们大概看一下 PHP7 支持哪些类型（zval 使用的类型标记）： 1234567891011121314151617181920/* regular data types */#define IS_UNDEF 0#define IS_NULL 1#define IS_FALSE 2#define IS_TRUE 3#define IS_LONG 4#define IS_DOUBLE 5#define IS_STRING 6#define IS_ARRAY 7#define IS_OBJECT 8#define IS_RESOURCE 9#define IS_REFERENCE 10/* constant expressions */#define IS_CONSTANT 11#define IS_CONSTANT_AST 12/* internal types */#define IS_INDIRECT 15#define IS_PTR 17 这个列表和 PHP5 使用的类似，不过增加了几项： IS_UNDEF 用来标记之前为 NULL 的 zval 指针（和 IS_NULL 并不冲突）。比如在上面的例子中使用 unset 注销变量； IS_BOOL 现在分割成了 IS_FALSE 和 IS_TRUE 两项。现在布尔类型的标记是直接记录到 type 中，这么做可以优化类型检查。不过这个变化对用户是透明的，还是只有一个『布尔』类型的数据（PHP 脚本中）。 PHP 引用不再使用 is_ref 来标记，而是使用 IS_REFERENCE 类型。这个也要放到下一部分讲； IS_INDIRECT 和 IS_PTR 是特殊的内部标记。 实际上上面的列表中应该还存在两个 fake types，这里忽略了。 IS_LONG 类型表示的是一个 zend_long 的值，而不是原生的 C 语言的 long 类型。原因是 Windows 的 64 位系统（LLP64）上的 long 类型只有 32 位的位深度。所以 PHP5 在 Windows 上只能使用 32 位的数字。PHP7 允许你在 64 位的操作系统上使用 64 位的数字，即使是在 Windows 上面也可以。 zend_refcounted 的内容会在下一部分讲。下面看看 PHP 引用的实现。 引用PHP7 使用了和 PHP5 中完全不同的方法来处理 PHP &amp; 符号引用的问题（这个改动也是 PHP7 开发过程中大量 bug 的根源）。我们先从 PHP5 中 PHP 引用的实现方式说起。 通常情况下， 写时复制原则意味着当你修改一个 zval 之前需要对其进行分离来保证始终修改的只是某一个 PHP 变量的值。这就是传值调用的含义。 但是使用 PHP 引用时这条规则就不适用了。如果一个 PHP 变量是 PHP 引用，就意味着你想要在将多个 PHP 变量指向同一个值。PHP5 中的 is_ref 标记就是用来注明一个 PHP 变量是不是 PHP 引用，在修改时需不需要进行分离的。比如： 123456&lt;?php$a = []; // $a -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[])$b =&amp; $a; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[])$b[] = 1; // $a = $b = zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[1]) // 因为 is_ref 的值是 1, 所以 PHP 不会对 zval 进行分离 但是这个设计的一个很大的问题在于它无法在一个 PHP 引用变量和 PHP 非引用变量之间共享同一个值。比如下面这种情况： 12345678910111213&lt;?php$a = []; // $a -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[])$b = $a; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[])$c = $b // $a, $b, $c -&gt; zval_1(type=IS_ARRAY, refcount=3, is_ref=0) -&gt; HashTable_1(value=[])$d =&amp; $c; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[]) // $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[]) // $d 是 $c 的引用, 但却不是 $a 的 $b, 所以这里 zval 还是需要进行复制 // 这样我们就有了两个 zval, 一个 is_ref 的值是 0, 一个 is_ref 的值是 1.$d[] = 1; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[]) // $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[1]) // 因为有两个分离了的 zval, $d[] = 1 的语句就不会修改 $a 和 $b 的值. 这种行为方式也导致在 PHP 中使用引用比普通的值要慢。比如下面这个例子： 1234&lt;?php$array = range(0, 1000000);$ref =&amp; $array;var_dump(count($array)); // &lt;-- 这里会进行分离 因为 count() 只接受传值调用，但是 $array 是一个 PHP 引用，所以 count() 在执行之前实际上会有一个对数组进行完整的复制的过程。如果 $array 不是引用，这种情况就不会发生了。 现在我们来看看 PHP7 中 PHP 引用的实现。因为 zval 不再单独分配内存，也就没办法再使用和 PHP5 中相同的实现了。所以增加了一个 IS_REFERENCE 类型，并且专门使用 zend_reference 来存储引用值： 1234struct _zend_reference &#123; zend_refcounted gc; zval val;&#125;; 本质上 zend_reference 只是增加了引用计数的 zval。所有引用变量都会存储一个 zval 指针并且被标记为 IS_REFERENCE。val 和其他的 zval 的行为一样，尤其是它也可以在共享其所存储的复杂变量的指针，比如数组可以在引用变量和值变量之间共享。 我们还是看例子，这次是 PHP7 中的语义。为了简洁明了这里不再单独写出 zval，只展示它们指向的结构体： 12345&lt;?php$a = []; // $a -&gt; zend_array_1(refcount=1, value=[])$b =&amp; $a; // $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[])$b[] = 1; // $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[1]) 上面的例子中进行引用传递时会创建一个 zend_reference，注意它的引用计数是 2（因为有两个变量在使用这个 PHP 引用）。但是值本身的引用计数是 1（因为 zend_reference 只是有一个指针指向它）。下面看看引用和非引用混合的情况： 123456789101112&lt;?php$a = []; // $a -&gt; zend_array_1(refcount=1, value=[])$b = $a; // $a, $b, -&gt; zend_array_1(refcount=2, value=[])$c = $b // $a, $b, $c -&gt; zend_array_1(refcount=3, value=[])$d =&amp; $c; // $a, $b -&gt; zend_array_1(refcount=3, value=[]) // $c, $d -&gt; zend_reference_1(refcount=2) ---^ // 注意所有变量共享同一个 zend_array, 即使有的是 PHP 引用有的不是$d[] = 1; // $a, $b -&gt; zend_array_1(refcount=2, value=[]) // $c, $d -&gt; zend_reference_1(refcount=2) -&gt; zend_array_2(refcount=1, value=[1]) // 只有在这时进行赋值的时候才会对 zend_array 进行赋值 这里和 PHP5 最大的不同就是所有的变量都可以共享同一个数组，即使有的是 PHP 引用有的不是。只有当其中某一部分被修改的时候才会对数组进行分离。这也意味着使用 count() 时即使给其传递一个很大的引用数组也是安全的，不会再进行复制。不过引用仍然会比普通的数值慢，因为存在需要为 zend_reference 结构体分配内存（间接）并且引擎本身处理这一块儿也不快的的原因。 结语总结一下 PHP7 中最重要的改变就是 zval 不再单独从堆上分配内存并且不自己存储引用计数。需要使用 zval 指针的复杂类型（比如字符串、数组和对象）会自己存储引用计数。这样就可以有更少的内存分配操作、更少的间接指针使用以及更少的内存分配。 文章的第二部分我们会讨论复杂类型的问题。 文章转自Scholer’s Blog - [译]变量在 PHP7 内部的实现（一）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中的引用变量和变量类型]]></title>
    <url>%2F2018%2F07%2F03%2FPHP%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[PHP中的引用变量在PHP中，引用意味着用不同的名字访问同一个变量内容。定义引用变量：使用&amp;符号。 PHP引用变量的原理普通变量赋值操作123$a = range(0,10);$b = $a;$a = range(0,20); 在执行如上代码时，将变量a赋值给变量b，这是并不会开辟新的内存空间，而是将变量a和b都指向同一个内存空间，当变量被改变时，才会重新开辟空间，这叫做COW(Copy Only Write)，又叫做“写时复制”原则。第一步(line1 line2)：第二步(line3): 引用变量赋值操作123$a = range(0,10);$b = &amp;$a;$a = range(0,20); 执行如上代码时，将a的引用赋值给b，此时同样不会开辟新的内存空间，和普通变量赋值不同的是，引用变量不遵循COW原则，当变量a被修改后，指向同一地址空间的变量b的值也会发生变化。第一步(line1 line2)：第二步(line3): 几点注意事项 unset() 只会取消引用，不会销毁空间。 对象和资源变量类型默认进行引用赋值，因此不会有COW原则。若想复制一个对象，使用clone()函数。 变量类型四种标量类型 boolean（布尔型） integer（整型） float（浮点型，也称作 double) string（字符串）三种复合类型 array（数组） object（对象） callable（可调用）两种特殊类型 resource（资源） NULL（无类型）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中到底是值传递还是引用传递？]]></title>
    <url>%2F2018%2F06%2F21%2FJava%E4%B8%AD%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[引言关于这个问题，很早之前就碰到过，也查过一些资料，但是网上的说法不统一，导致我一直是似懂非懂的状态，结果今天在刷题的时候又遇到了这个问题，于是我决定梳理一下这块内容，把这个坑给填上。要弄明白这个问题，首先要明确什么是值传递什么是引用传递。值传递：表示方法接收的是调用者提供的值。引用传递：表示方法接收的是调用者提供的变量地址。在Horstman的《JAVA核心技术》上说：“java程序设计语言总是采用值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。” Java基本类型和引用类型的区别存储方式12int num = 10;String str = &quot;hello&quot;; 如图中所示，number属于8种基本类型中的int，所以它的值直接保存在变量中；而str属于引用类型，变量中b保存的是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。 赋值运算的过程12num = 20;str = &quot;java&quot;; 对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收） 调用方法传递参数时发生了什么12345678910111213141516171819202122232425//第一个例子：基本类型void foo(int value) &#123; value = 100;&#125;foo(num); // num 没有被改变//第二个例子：引用类型，但是没有提供改变自身的方法void foo(String text) &#123; text = &quot;windows&quot;;&#125;foo(str); // str 也没有被改变//第三个例子：引用类型，提供了改变自身方法StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder.append(&quot;4&quot;);&#125;foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。//第四个例子：引用类型，提供了改变自身方法，但是不使用，而是使用赋值运算符。StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder = new StringBuilder(&quot;ipad&quot;);&#125;foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。 为什么第三个例子中的sb改变而第四个例子却没有改变呢？下面是第三个例子的执行过程图示在执行了builder.append(“4”)之后，可以看出对象是被直接修改了的，所以函数之外的变量也会被修改而第四个例子中，在执行builder = new StringBuilder(“ipad”)之后，builder变量被指向了一个新的对象，而原来的对象还是存在的，函数外面的变量也是一直指向原来的对象地址 总结在Java中，局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，而对象是存储在堆中的。栈中存储的引用指向堆中的对象，因此只有当我们修改了堆中的对象时，原本函数外指向这个对象的变量才会改变。在C/C++中存在指针，可以使用*p的方式直接访问堆中的对象；而在Java中是不存在指针的，所以要使用点操作符来修改对象。例如上文第三个例子中 builder.append(“4”) 就是让对象调用append()方法，从而修改builder指向的对象。而上文第四个例子中，执行builder = new StringBuilder(“ipad”)修改的是栈中的引用，根本就没有访问堆中的对象，所以无法对方法外的变量造成影响。经过上面的分析，我们终于知道引言中Horstman那句话的意思了，Java方法中传入参数都是拷贝，无法被修改。简单来说，就是在以传值的方式传引用，或者说是传值的方式传地址下面是Java中参数传递的总结： 一个方法不能修改一个基本数据类型的参数 一个方法可以修改一个对象参数的状态 一个方法不能实现让对象参数引用一个新对象 参考资料：知乎 - Intopass和流浪的小鼠的回答独恋幽兰的专栏]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2F2018%2F06%2F16%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[背景介绍字符串匹配是一个很常见的问题。例如：判断文本字符串”BBC ABCDAB ABCDABCDABDE”里面是否包含另一个模式字符串”ABCDABD”。一般的思路很简单，只需要将两个字符串从头开始比较即可（分别使用i、j标识文本字符串和模式字符串的比较位置），若字符相同，则将两个字符串同时向后移一位（i++,j++）；若不同，将文本串串回溯至初始比较位置的下一位（i=i-j+1）,将模式串移动至头部（j=0），直到完全匹配或遍历完整个文本字符串。上面的方法就是暴力匹配算法，但是这种简单粗暴的算法效率上存在着很大的问题，如上面提到的，当i=10,j=6时，字符串会失配，如下图按照暴力匹配算法的话就会将模式串移到头部，文本串移到i=5的位置这样做虽然可行，但是效率很差，因为你要把”搜索位置”（指针i）移到已经比较过的位置，重比一遍。当空格与D不匹配时，其实知道前面六个字符是”ABCDAB”，所以其实是没有必要将文本串回溯到i-j+1的位置的。 KMP算法简述KMP算法是由Donald Knuth、Vaughan Pratt、James H. Morris三人联合发表，作用就是查找文本串中是否包含特定的模式串。它的基本思想就是设法利用已知信息，不把”搜索位置”（指针i）移回已经比较过的位置，而是继续把它向后移，这样就会大大提高匹配效率。下面我简述一下KMP算法的流程， 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），令i++，j++，继续匹配下一个字符；如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 使用之前的例子的话就像下面这样然后我们的问题就变成了模式串P应该向前移动多少位，即next[j]的值是什么。 next数组由上面可知，那么next[j]就表示模式串中第j位失配后下一步需要移动到的位置，实际移动的位数为：j-next[j]。next数组和文本串是无关的，但是怎么求得next数组呢？通过观察上面的例子我们可以看到，失配时移动到的位置k（也就是next[j]）存在着这样一个性质：最前面的k个字符和j之前的最后k个字符是一样的。数学公式表示就像下面这样 P[0 ~ k-1] = P[j-k ~ j-1] 真前缀和真后缀的最大公共长度所以我们要先求模式串中真前缀和真后缀的最大公共长度。下面是关于（真）前缀后缀的定义（在阮一峰大佬的博客中混淆了前/后缀和真前/后缀的概念，看来大佬也有粗心的时候啊）。1234字符串的前缀是指一个字符串全部头部组合，包括最后一个字符；字符串的真前缀是指除了最后一个字符以外，一个字符串的全部尾部组合；字符串的后缀是指一个字符串全部头部组合，包括第一个字符；字符串的真后缀是指除了第一个字符以外，一个字符串的全部尾部组合。 下面是一个字符串“abab”的真前缀真后缀最大公共长度表 模式串 a b a b 真前缀真后缀最大公共长度表 -1 0 0 1 把初始值赋值为-1，可以方便匹配操作。 next数组的求解重头戏终于来了，我们可以用递推的方法来求解next数组，如下图:可以发现，当P[k] == p[j]时，有next[j+1] = k+1.关于这个结论证明如下：已经知道P[0 ~ k-1] == P[j-k ~ j-1]，并且P[k] == p[j]所以P[0 ~ k] == P[j-k ~ j],即next[j+1] = k+1 = next[j]+1. 当P[k] != P[j]的时候呢，如图：执行k=next[k],然后继续比较P[k]与P[j]。不停循环上面的步骤，直到P[k] == P[j]或者k=-1。通过上面的图我们应该知道为什么使k=next[k]，因为匹配不到”ABAAB”这样的串了，但是会有可能匹配到”AB”、”B”这样的串，此过程相当于模式串的自我匹配，所以不断的递归k = next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。这样我们就可以写出计算next数组的代码了1234567891011121314151617181920public int [] getNext(String ps)&#123; char[] p = ps.toCharArray(); int length = p.length; int[] next = new int[length]; next[0] = -1; int j = 0; int k = -1; while (j &lt; length-1)&#123; if (k==-1 || p[j]==p[k])&#123; ++j; ++k; next[j] = k; &#125;else&#123; k = next[k]; &#125; &#125; return next;&#125; 下面是KMP搜索的代码123456789101112131415161718192021public int KMPsearch(String ts,String ps)&#123; char[] t = ts.toCharArray(); char[] p = ps.toCharArray(); int i = 0; int j = 0; int sLength = t.length; int pLength = p.length; int [] next = this.getNext(ps); while (i&lt;sLength &amp;&amp; j&lt;pLength)&#123; if (j==-1 || t[i]==p[j])&#123; i++; j++; &#125;else &#123; j=next[j]; &#125; &#125; if (j == pLength) return i - j; else return -1;&#125; Next数组的优化表面上我们已经完成了所有工作，但是我们忽略了一个问题:比如，如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1，当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。修改后的代码如下：1234567891011121314151617181920212223public int [] getNext(String ps)&#123; char[] p = ps.toCharArray(); int length = p.length; int[] next = new int[length]; next[0] = -1; int j = 0; int k = -1; while (j &lt; length-1)&#123; if (k==-1 || p[j]==p[k])&#123; ++j; ++k; if (p[j] == p[k]) next[j] = next[k]; else next[j] = k; &#125;else&#123; k = next[k]; &#125; &#125; return next;&#125; 参考文章字符串匹配的KMP算法-阮一峰的网络日志从头到尾彻底理解KMP详解KMP算法]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态链表]]></title>
    <url>%2F2018%2F05%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是静态链表静态链表是使用数组描述的链表，在使用C语言中的结构体数组定义时，结构体变量中包括数据data和游标cur。1234567//---------线性表的静态单链表存储结构--------#define MAXSIZE 100typedef struct&#123; ElemType data; int cur;&#125;SLinkList[MAXSIZE]; 对数组的特殊处理 数组的第一个和最后一个元素做特殊处理，他们的data不存放数据。 通常把未使用的数组元素称为备用链表。 数组的第一个元素，即下标为0的那个元素cur就存放备用链表的第一个节点的下标。 数组的最后一个元素，及下标为MAXSIZE-1的cur则存放的第一个有数值的元素的下标，相当于单链表中的头结点作用。 已使用的链表的最后一个元素游标为0。 下标 0 1 2 3 4 5 6 … 999 数据 A C D E … 游标 5 2 3 4 0 6 7 … 1 如上表，下标为0的元素中数据为空，游标为5，指向备用链表的首元素，下标为1,2,3,4的元素数据不为空，游标指向后继元素；最后一个元素下标为999，数据为空，游标指向首链表首元素下表为1。 Java实现相关操作12345678910//初始化静态链表public StaticLink[] init(int length)&#123; StaticLink [] staticLinks = new StaticLink[length]; for (int i=0;i&lt;length-1;i++)&#123; staticLinks[i].cur = i+1; &#125; staticLinks[length-1].cur = 0; return staticLinks;&#125; 12345678//分配链表空间private int mallocStaticLink(StaticLink[] staticLinks)&#123; int i = staticLinks[0].cur; if(i != 0) staticLinks[0].cur = staticLinks[i].cur; return i;&#125; 12345//释放链表空间public void freeStaticLink(StaticLink[] staticLinks,int index)&#123; staticLinks[index].cur = staticLinks[0].cur; staticLinks[0].cur = index;&#125; 123456789101112131415161718192021//向静态链表中插入元素public void insert(StaticLink[] staticLinks,int local,char data)&#123; int length = staticLinks.length; int k = 1; int index = staticLinks[length-1].cur; if(local&lt;1 || local&gt;length-1)&#123; return; &#125; int j = this.mallocStaticLink(staticLinks); if (j != 0)&#123; while (k&lt;local-1)&#123; index = staticLinks[index].cur; //获取插入指定位置的前一个元素的下标 k++; &#125; staticLinks[j].data = data; staticLinks[j].cur = staticLinks[index].cur; staticLinks[index].cur = index; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>静态链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis持久化]]></title>
    <url>%2F2018%2F03%2F27%2FRedis%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[概述大家都知道，Redis是内存数据库，它会把数据都储存在内存当中，可以大幅提高读取速度，但这也出现一个问题，数据易丢失。所以，将内存中的数据持久化处理是很有必要的。Redis共提供了两种持久化的方式，RDB全量写入方式和AOF增量写入方式。 RDB全量写入方式RDB就是将整个redis中的内容dump下来，做一个快照。RDB是redis默认的持久化方式。 相关配置123456save 900 1save 300 10save 60 10000rdbchecksum yes #是否校验rdb文件dbfilename &quot;redis-6379.rdb&quot; #持久化文件名称dir &quot;/data/dbs/redis/6379&quot; #持久化数据文件存放的路径 前三行是触发RDB的条件，意思是当900秒中redis有一条数据写入就会进行RDB操作，二三行同上。 相关命令savesave是以阻塞的方式将redis的数据写入rdb文件，是redis主进程进行此项操作，直到该文件创建完毕的这段时间内redis将不能处理任何命令请求。 bgsave执行bgsave操作时，redis主进程会先fork一个子进程，由子进程将数据写入rdb文件。这种方式耗费的资源比save要多。 AOF增量写入方式AOF类似于日志，会将对redis的所有操作写入aof文件中，方便数据的恢复。 相关配置123456dir &quot;/data/dbs/redis/6379&quot; #AOF文件存放目录appendonly yes #开启AOF持久化，默认关闭appendfilename &quot;redis-6379.aof&quot; #AOF文件名称appendfsync no #AOF持久化策略auto-aof-rewrite-percentage 100 #触发AOF文件重写的条件，增量百分比auto-aof-rewrite-min-size 64mb #触发AOF文件重写的条件，文件大小 三种触发持久化的策略第四行是AOF持久化的策略，AOF共有三种持久化策略，分别为always、everysec 、no。 always策略是每提交一个修改命令都调用fsync刷新到AOF文件 everysec策略是每秒钟都调用fsync将一秒内的修改刷新至AOF文件，但可能会丢失一秒以内的数据 noc策略是依靠OS进行刷新，redis不主动刷新AOF AOF文件重写我们知道，AOF持久化会记录redis的每一条修改指令，所以AOF文件会变得非常非常的大。因此redis实现了AOF文件重写的方法，就是会合并对相同key的操作。例如：key的值为1， INCR key操作进行了5次，AOF重写后变为SET key 6。查了相关的资料，发现这个“重写”的说法是有歧义的。AOF重写并不是对原有AOF文件进行任何写入和读取，而是根据目前的结果来用相应的语句实现。讲了这么多，redis配置文件中有关重写的配置有auto-aof-rewrite-percentage和auto-aof-rewrite-min-size。第一个的意思是达到文件增量的百分比时触发重写，默认为100%；第二个是文件大小达到指定大小触发重写，默认为64mb。 两种持久化方式的比较 RDB AOF 恢复优先级 低 高 文件体积 小 大 恢复速度 快 慢 数据安全性 易丢数据 根据策略决定 轻重 重 轻]]></content>
      <categories>
        <category>redis学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos下配置Supervisor]]></title>
    <url>%2F2018%2F03%2F26%2Fcentos%E4%B8%8B%E9%85%8D%E7%BD%AESupervisor%2F</url>
    <content type="text"><![CDATA[背景最近项目中需要用到Supervisor来保证进程能持续运行，Supervisor官网中是这样介绍的Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。 配置过程安装服务器环境为CentOS7.2，使用wget命令下载源码安装，安装过程中可能会需要几个依赖的包，根据提示自行下载即可。 supervisor的配置安装完成后，使用echo_supervisord_conf打印出一个配置文件的样本，样本如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254[unix_http_server] file=/tmp/supervisor.sock ; socket文件的路径，supervisorctl用XML_RPC和supervisord通信就是通过它进行 的。如果不设置的话，supervisorctl也就不能用了 不设置的话，默认为none。 非必须设置 ;chmod=0700 ; 这个简单，就是修改上面的那个socket文件的权限为0700 不设置的话，默认为0700。 非必须设置;chown=nobody:nogroup ; 这个一样，修改上面的那个socket文件的属组为user.group 不设置的话，默认为启动supervisord进程的用户及属组。非必须设置;username=user ; 使用supervisorctl连接的时候，认证的用户 不设置的话，默认为不需要用户。 非必须设置;password=123 ; 和上面的用户名对应的密码，可以直接使用明码，也可以使用SHA加密 如：&#123;SHA&#125;82ab876d1387bfafe46cc1c8a2ef074eae50cb1d 默认不设置。。。非必须设置;[inet_http_server] ; 侦听在TCP上的socket，Web Server和远程的supervisorctl都要用到他 不设置的话，默认为不开启。非必须设置;port=127.0.0.1:9001 ; 这个是侦听的IP和端口，侦听所有IP用 :9001或*:9001。 这个必须设置，只要上面的[inet_http_server]开启了，就必须设置它;username=user ; 这个和上面的uinx_http_server一个样。非必须设置;password=123 ; 这个也一个样。非必须设置[supervisord] ;这个主要是定义supervisord这个服务端进程的一些参数的 这个必须设置，不设置，supervisor就不用干活了logfile=/tmp/supervisord.log ; 这个是supervisord这个主进程的日志路径，注意和子进程的日志不搭嘎。 默认路径$CWD/supervisord.log，$CWD是当前目录。。非必须设置logfile_maxbytes=50MB ; 这个是上面那个日志文件的最大的大小，当超过50M的时候，会生成一个新的日 志文件。当设置为0时，表示不限制文件大小 默认值是50M，非必须设置。 logfile_backups=10 ; 日志文件保持的数量，上面的日志文件大于50M时，就会生成一个新文件。文件 数量大于10时，最初的老文件被新文件覆盖，文件数量将保持为10 当设置为0时，表示不限制文件的数量。 默认情况下为10。。。非必须设置loglevel=info ; 日志级别，有critical, error, warn, info, debug, trace, or blather等 默认为info。。。非必须设置项pidfile=/tmp/supervisord.pid ; supervisord的pid文件路径。 默认为$CWD/supervisord.pid。。。非必须设置nodaemon=false ; 如果是true，supervisord进程将在前台运行 默认为false，也就是后台以守护进程运行。。。非必须设置minfds=1024 ; 这个是最少系统空闲的文件描述符，低于这个值supervisor将不会启动。 系统的文件描述符在这里设置cat /proc/sys/fs/file-max 默认情况下为1024。。。非必须设置minprocs=200 ; 最小可用的进程描述符，低于这个值supervisor也将不会正常启动。 ulimit -u这个命令，可以查看linux下面用户的最大进程数 默认为200。。。非必须设置;umask=022 ; 进程创建文件的掩码 默认为022。。非必须设置项;user=chrism ; 这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。 我这里面设置的这个用户，也可以对supervisord进行管理 默认情况是不设置。。。非必须设置项;identifier=supervisor ; 这个参数是supervisord的标识符，主要是给XML_RPC用的。当你有多个 supervisor的时候，而且想调用XML_RPC统一管理，就需要为每个 supervisor设置不同的标识符了 默认是supervisord。。。非必需设置;directory=/tmp ; 这个参数是当supervisord作为守护进程运行的时候，设置这个参数的话，启动 supervisord进程之前，会先切换到这个目录 默认不设置。。。非必须设置;nocleanup=true ; 这个参数当为false的时候，会在supervisord进程启动的时候，把以前子进程 产生的日志文件(路径为AUTO的情况下)清除掉。有时候咱们想要看历史日志，当 然不想日志被清除了。所以可以设置为true 默认是false，有调试需求的同学可以设置为true。。。非必须设置;childlogdir=/tmp ; 当子进程日志路径为AUTO的时候，子进程日志文件的存放路径。 默认路径是这个东西，执行下面的这个命令看看就OK了，处理的东西就默认路径 python -c &quot;import tempfile;print tempfile.gettempdir()&quot; 非必须设置;environment=KEY=&quot;value&quot; ; 这个是用来设置环境变量的，supervisord在linux中启动默认继承了linux的 环境变量，在这里可以设置supervisord进程特有的其他环境变量。 supervisord启动子进程时，子进程会拷贝父进程的内存空间内容。 所以设置的 这些环境变量也会被子进程继承。 小例子：environment=name=&quot;haha&quot;,age=&quot;hehe&quot; 默认为不设置。。。非必须设置;strip_ansi=false ; 这个选项如果设置为true，会清除子进程日志中的所有ANSI 序列。什么是ANSI 序列呢？就是我们的\n,\t这些东西。 默认为false。。。非必须设置; the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor] ;这个选项是给XML_RPC用的，当然你如果想使用supervisord或者web server 这 个选项必须要开启的supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface [supervisorctl] ;这个主要是针对supervisorctl的一些配置 serverurl=unix:///tmp/supervisor.sock ; 这个是supervisorctl本地连接supervisord的时候，本地UNIX socket 路径，注意这个是和前面的[unix_http_server]对应的 默认值就是unix:///tmp/supervisor.sock。。非必须设置;serverurl=http://127.0.0.1:9001 ; 这个是supervisorctl远程连接supervisord的时候，用到的TCP socket路径 注意这个和前面的[inet_http_server]对应 默认就是http://127.0.0.1:9001。。。非必须项 ;username=chris ; 用户名 默认空。。非必须设置;password=123 ; 密码 默认空。。非必须设置;prompt=mysupervisor ; 输入用户名密码时候的提示符 默认supervisor。。非必须设置;history_file=~/.sc_history ; 这个参数和shell中的history类似，我们可以用上下键来查找前面执行过的命令 默认是no file的。。所以我们想要有这种功能，必须指定一个文件。。。非 必须设置; The below sample program section shows all possible program subsection values,; create one or more &apos;real&apos; program: sections to be able to control them under; supervisor.;[program:theprogramname] ;这个就是咱们要管理的子进程了，&quot;:&quot;后面的是名字，最好别乱写和实际进程 有点关联最好。这样的program我们可以设置一个或多个，一个program就是 要被管理的一个进程;command=/bin/cat ; 这个就是我们的要启动进程的命令路径了，可以带参数 例子：/home/test.py -a &apos;hehe&apos; 有一点需要注意的是，我们的command只能是那种在终端运行的进程，不能是 守护进程。这个想想也知道了，比如说command=service httpd start。 httpd这个进程被linux的service管理了，我们的supervisor再去启动这个命令 这已经不是严格意义的子进程了。 这个是个必须设置的项;process_name=%(program_name)s ; 这个是进程名，如果我们下面的numprocs参数为1的话，就不用管这个参数 了，它默认值%(program_name)s也就是上面的那个program冒号后面的名字， 但是如果numprocs为多个的话，那就不能这么干了。想想也知道，不可能每个 进程都用同一个进程名吧。 ;numprocs=1 ; 启动进程的数目。当不为1时，就是进程池的概念，注意process_name的设置 默认为1 。。非必须设置;directory=/tmp ; 进程运行前，会前切换到这个目录 默认不设置。。。非必须设置;umask=022 ; 进程掩码，默认none，非必须;priority=999 ; 子进程启动关闭优先级，优先级低的，最先启动，关闭的时候最后关闭 默认值为999 。。非必须设置;autostart=true ; 如果是true的话，子进程将在supervisord启动后被自动启动 默认就是true 。。非必须设置;autorestart=unexpected ; 这个是设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected 和true。如果为false的时候，无论什么情况下，都不会被重新启动， 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退 出码的时候，才会被自动重启。当为true的时候，只要子进程挂掉，将会被无 条件的重启;startsecs=1 ; 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启 动成功了 默认值为1 。。非必须设置;startretries=3 ; 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把 此进程的状态置为FAIL 默认值为3 。。非必须设置;exitcodes=0,2 ; 注意和上面的的autorestart=unexpected对应。。exitcodes里面的定义的 退出码是expected的。;stopsignal=QUIT ; 进程停止信号，可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2等信号 默认为TERM 。。当用设定的信号去干掉进程，退出码会被认为是expected 非必须设置;stopwaitsecs=10 ; 这个是当我们向子进程发送stopsignal信号后，到系统返回信息 给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该 子进程发送一个强制kill的信号。 默认为10秒。。非必须设置;stopasgroup=false ; 这个东西主要用于，supervisord管理的子进程，这个子进程本身还有 子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程 有可能会变成孤儿进程。所以咱们可以设置可个选项，把整个该子进程的 整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。 需要注意的是，该选项发送的是stop信号 默认为false。。非必须设置。。;killasgroup=false ; 这个和上面的stopasgroup类似，不过发送的是kill信号;user=chrism ; 如果supervisord是root启动，我们在这里设置这个非root用户，可以用来 管理该program 默认不设置。。。非必须设置项;redirect_stderr=true ; 如果为true，则stderr的日志会被写入stdout日志文件中 默认为false，非必须设置;stdout_logfile=/a/path ; 子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项。 设置为none的话，将没有日志产生。设置为AUTO的话，将随机找一个地方 生成日志文件，而且当supervisord重新启动的时候，以前的日志文件会被 清空。当 redirect_stderr=true的时候，sterr也会写进这个日志文件;stdout_logfile_maxbytes=1MB ; 日志文件最大大小，和[supervisord]中定义的一样。默认为50;stdout_logfile_backups=10 ; 和[supervisord]定义的一样。默认10;stdout_capture_maxbytes=1MB ; 这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout 发送信息，而supervisor可以根据信息，发送相应的event。 默认为0，为0的时候表达关闭管道。。。非必须项;stdout_events_enabled=false ; 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将 触发supervisord发送PROCESS_LOG_STDOUT类型的event 默认为false。。。非必须设置;stderr_logfile=/a/path ; 这个东西是设置stderr写的日志路径，当redirect_stderr=true。这个就不用 设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中 默认为AUTO，也就是随便找个地存，supervisord重启被清空。。非必须设置;stderr_logfile_maxbytes=1MB ; 这个出现好几次了，就不重复了;stderr_logfile_backups=10 ; 这个也是;stderr_capture_maxbytes=1MB ; 这个一样，和stdout_capture一样。 默认为0，关闭状态;stderr_events_enabled=false ; 这个也是一样，默认为false;environment=A=&quot;1&quot;,B=&quot;2&quot; ; 这个是该子进程的环境变量，和别的子进程是不共享的;serverurl=AUTO ; ; The below sample eventlistener section shows all possible; eventlistener subsection values, create one or more &apos;real&apos;; eventlistener: sections to be able to handle event notifications; sent by supervisor.;[eventlistener:theeventlistenername] ;这个东西其实和program的地位是一样的，也是suopervisor启动的子进 程，不过它干的活是订阅supervisord发送的event。他的名字就叫 listener了。我们可以在listener里面做一系列处理，比如报警等等 楼主这两天干的活，就是弄的这玩意;command=/bin/eventlistener ; 这个和上面的program一样，表示listener的可执行文件的路径;process_name=%(program_name)s ; 这个也一样，进程名，当下面的numprocs为多个的时候，才需要。否则默认就 OK了;numprocs=1 ; 相同的listener启动的个数;events=EVENT ; event事件的类型，也就是说，只有写在这个地方的事件类型。才会被发送 ;buffer_size=10 ; 这个是event队列缓存大小，单位不太清楚，楼主猜测应该是个吧。当buffer 超过10的时候，最旧的event将会被清除，并把新的event放进去。 默认值为10。。非必须选项;directory=/tmp ; 进程执行前，会切换到这个目录下执行 默认为不切换。。。非必须;umask=022 ; 淹没，默认为none，不说了;priority=-1 ; 启动优先级，默认-1，也不扯了;autostart=true ; 是否随supervisord启动一起启动，默认true;autorestart=unexpected ; 是否自动重启，和program一个样，分true,false,unexpected等，注意 unexpected和exitcodes的关系;startsecs=1 ; 也是一样，进程启动后跑了几秒钟，才被认定为成功启动，默认1;startretries=3 ; 失败最大尝试次数，默认3;exitcodes=0,2 ; 期望或者说预料中的进程退出码，;stopsignal=QUIT ; 干掉进程的信号，默认为TERM，比如设置为QUIT，那么如果QUIT来干这个进程 那么会被认为是正常维护，退出码也被认为是expected中的;stopwaitsecs=10 ; max num secs to wait b4 SIGKILL (default 10);stopasgroup=false ; send stop signal to the UNIX process group (default false);killasgroup=false ; SIGKILL the UNIX process group (def false);user=chrism ;设置普通用户，可以用来管理该listener进程。 默认为空。。非必须设置;redirect_stderr=true ; 为true的话，stderr的log会并入stdout的log里面 默认为false。。。非必须设置;stdout_logfile=/a/path ; 这个不说了，好几遍了;stdout_logfile_maxbytes=1MB ; 这个也是;stdout_logfile_backups=10 ; 这个也是;stdout_events_enabled=false ; 这个其实是错的，listener是不能发送event;stderr_logfile=/a/path ; 这个也是;stderr_logfile_maxbytes=1MB ; 这个也是;stderr_logfile_backups ; 这个不说了;stderr_events_enabled=false ; 这个也是错的，listener不能发送event;environment=A=&quot;1&quot;,B=&quot;2&quot; ; 这个是该子进程的环境变量 默认为空。。。非必须设置;serverurl=AUTO ; override serverurl computation (childutils); The below sample group section shows all possible group values,; create one or more &apos;real&apos; group: sections to create &quot;heterogeneous&quot;; process groups.;[group:thegroupname] ;这个东西就是给programs分组，划分到组里面的program。我们就不用一个一个去操作了 我们可以对组名进行统一的操作。 注意：program被划分到组里面之后，就相当于原来 的配置从supervisor的配置文件里消失了。。。supervisor只会对组进行管理，而不再 会对组里面的单个program进行管理了;programs=progname1,progname2 ; 组成员，用逗号分开 这个是个必须的设置项;priority=999 ; 优先级，相对于组和组之间说的 默认999。。非必须选项; The [include] section can just contain the &quot;files&quot; setting. This; setting can list multiple files (separated by whitespace or; newlines). It can also contain wildcards. The filenames are; interpreted as relative to this file. Included files *cannot*; include files themselves.;[include] ;这个东西挺有用的，当我们要管理的进程很多的时候，写在一个文件里面 就有点大了。我们可以把配置信息写到多个文件中，然后include过来;files = relative/directory/*.ini 以上配置中[unix_http_server]下的file=/tmp/supervisor.sock最好改成/var/supervisor.sock,以防系统自动清除，其他配置中含有/tmp的最好也改一下，原因同上。还有一个问题就是如果想要使用web界面查看supervisor需要开启[inet_http_server]。 进程配置12345678910111213[program:getcash]directory = /home/wwwroot/xiaotx/domain/ ; 程序的启动目录command = php think queue:work --queue get_cash --daemon --sleep 1800 --memory 128 ; 启动命令autostart = true ; 在 supervisord 启动的时候也自动启动startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true ; 程序异常退出后自动重启startretries = 3 ; 启动失败自动重试次数，默认是 3user = www ; 用哪个用户启动redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile = /data/logs/getcash.log]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中精度丢失的问题]]></title>
    <url>%2F2018%2F03%2F20%2FPHP%E4%B8%AD%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述在做微信支付时，需要将浮点数（以元为单位）转换为整数（以分为单位），结果出现了匪夷所思的问题，代码如下123$num = 9.7*100;echo $num; //结果为970echo (int)$num; //结果为969 问题原因突然想到之前在学习JavaScript的时候看到IEEE754格式，浮点数操作时会出现精度丢失的问题。去看了一下官网手册，果然是这个原因。 浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754 双精度格式，则由于取整而导致的最大相对误差为 1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运算时的误差传递。此外，以十进制能够精确表示的有理数如 0.1 或 0.7，无论有多少尾数都不能被内部所使用的二进制精确表示，因此不能在不丢失一点点精度的情况下转换为二进制的格式。这就会造成混乱的结果：例如，floor((0.1+0.7)*10) 通常会返回 7 而不是预期中的 8，因为该结果内部的表示其实是类似 7.9999999999999991118…。所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数。 解决方案 采用php中的round()函数对浮点数进行四舍五入，然后进行取整。 1(int)round((0.1+0.7)*10) 先将浮点数转换为字符串，然后转换为整数 1(int)(string)((0.1+0.7)*10) 这篇文章详细的介绍了出现精度丢失的原因，直接上链接http://justjavac.com/codepuzzle/2012/11/11/codepuzzle-float-who-stole-your-accuracy.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延迟消息队列-时间轮]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%97%B6%E9%97%B4%E8%BD%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>系统架构</tag>
        <tag>延迟消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于订单状态自动更新的思考和实现]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%85%B3%E4%BA%8E%E8%AE%A2%E5%8D%95%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[问题描述（背景）在所有电商交易平台中都会遇到订单状态需要自动流转的问题，比如用户下单未付款30分钟后自动关闭订单、在商家发货15天之后如用户未确认收货自动将订单变为收货状态等等。我查找了一些相关的资料，发现有很多解决方案，下面将列出几个我认为比较经典的方案。 解决方案1.被动更新这是最笨也是最麻烦的办法，就是在用户每一次操作时，都需要进行一个订单状态及时间的判断，假设用户一直没有对用户进行操作，那么订单的状态永远不会被更新。 缺点：每次订单操作前都会对订单状态进行判断，假设订单数量很大时，会浪费大量资源；而且随着订单操作方法越来越多，会变得非常不好管理。 2.轮询这也是一个比较直接的思路，可以利用Linux中的cron定时任务来定时扫订单表，取出所有需要更新状态的订单进行更新操作。 缺点：第一个是轮序的时间粒度很难把握，粒度大的话会导致很多订单状态更新的不够及时，力度小的话或耗费大量的资源；另一个就是随着时间的增加，数据库中的订单数量会越来越多，全表扫描会占用数据库大量资源。 3.利用redis做延迟消息队列（改进方法2中的不足）由于最近学了redis，就在思考怎么使用redis来解决这个问题，毕竟相同配置下的redis的QPS/TPS要远远大于mysql的，而且也不能像方法2中的那样毫无区分的进行全表扫描，那样不但效率低而且会浪费大量的资源。能不能只把有可能会进行自动更新状态的订单放到redis中呢，其实这样就是一个延迟消息队列的雏形了。那么还有没有需要改进的地方呢，上面说到轮询的时间粒度是很难把握的，那能不能用动态的时间扫一个队列呢？我们知道redis中有一个叫做score set(有序集合)的数据类型，我们可以把要更新的时间写到有序集合的score中，一个有序集合按照由小到大排列，这样的话每个队列的第一个元素中的score就决定了我们timer定时器的休眠时间。 下面总结一下改进的地方： 使用消息队列的结构替代方法2中的全表扫描，更多的节省了资源，提高了效率 根据队列首个元素的延迟时间动态规划定时器的扫描间隔，避免无必要的扫描 能够灵活的添加、删除延迟任务]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>系统架构</tag>
        <tag>延迟消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis中的pipline]]></title>
    <url>%2F2018%2F03%2F07%2FRedis%E4%B8%AD%E7%9A%84pipline%2F</url>
    <content type="text"><![CDATA[什么是流水线 流水线就是将批量命令打包，通过一次网络传输进行操作执行的过程。 批量网络命令通信：n次时间 = n次网络时间 + n次执行时间 流水线命令通信：n次时间 = 1次网络时间 + n次执行时间 主要是为了解决命令在网络传输中耗时长的问题 与原生操作的对比原生批量操作命令如mset,mset等是原子的，而pipline不是原子操作。]]></content>
      <categories>
        <category>redis学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis慢查询]]></title>
    <url>%2F2018%2F03%2F07%2FRedis%E6%85%A2%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[redis的生命周期 redis的慢查询发生在第三个阶段 关于慢查询的两个配置slowlog-max-len 储存慢查询信息的队列长度 在redis中，慢查询语句存储在一个固定长度的先进先出队列当中，它们被保存在内存当中。 slowlog-log-slower-than 慢查询阈值 单位是微秒 slowlog-log-slower-than=0,记录所有命令 slowlog-log-slower-than&lt;0,不记录慢查询 慢查询命令 slowlog get[n]: 获取慢查询队列，n为获取的数量 slowlog len: 获取慢查询队列的长度 slow reset: 清空慢查询队列 配置慢查询注意事项 slowlog-max-len不要设置过大，默认10ms，通常1ms slowlog-log-slower-than不要设置过小，通常1000左右 理解生命周期 定期持久化慢查询]]></content>
      <categories>
        <category>redis学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis的特性]]></title>
    <url>%2F2018%2F03%2F05%2FRedis%E7%9A%84%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[速度快 数据存在内存（主要原因）; 使用C语言编写; 采用单线程线程模型 持久化（断电不丢失）Redis所有数据保存在内存当中，对数据的更新将异步的保存在磁盘中。 多种数据机构 主要数据结构 字符串 (String) 哈希 (Hash Tables) 列表（Linked Lists） 集合 (Sets) 有序集合 (Sorted Sets) 衍生数据结构 位图（BitMaps） 超小内存唯一值计数（HyperLogLog） 地理信息定位（GEO） 支持多种客户端语言支持像java、php、python等多种主流语言 功能丰富 发布订阅 Lua脚本 简单事务功能 pipeline “简单” 不依赖外部库; 单线程编程模型，开发容易 主从复制高可用、分布式 Redis-Sentinel(v2.8)支持高可用; Redis-Cluster(v3.0)支持分布式]]></content>
      <categories>
        <category>redis学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议-ICMP]]></title>
    <url>%2F2018%2F01%2F16%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-ICMP%2F</url>
    <content type="text"><![CDATA[ICMP引言产生背景ICMP为了补偿IP的缺陷而设计的。ICMP提供路由器报告错误，提供主机测试目的端是否能到达。 概述ICMP是Internet控制消息协议的缩写，属于网络层协议。ICMP只能报告差错，不能纠正差错。 ICMP的封装 ICMP报文不直接传给链路层，而是封装成IP数据报，再传给数据链路层。 ICMP总是把差错报文给最初的数据源，而不是通知中间服务器。 ICMP差错和查询报文 ICMPv6版本4和版本6的比较 在版本4中的ICMP，ARP和IGMP合并成一个协议ICMPv6。]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议-底层技术]]></title>
    <url>%2F2018%2F01%2F15%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[有线局域网以太网（Ethernet） 以太网发送的分组称为帧，每个帧含有7个字段：前同步码、帧首定界符、目标地址、源地址、长度/类型、数据和填充、FCS(CRC)。 以太网不提供任何机制来确定收到的帧，所以以太网是一种被称为不可靠的媒体。 以太网帧长度最小为64bytes(512bits)，最大为1518bytes(12,144bits)。 802.3和802.2 IEEE 正式的标准，它由Ethernet V2发展而来。它将Ethernet V2帧头的协议类型字段替换为帧长度字段(取值为0x0000-0x05dc（十进制1500）)；并加入802.2 LLC头用以标志上层协议。 以太网提供的服务对应于OSI模型的第一层和第二层，而802.3提供的服务对应于OSI模型的第一层和第二层的信道访问部分（即第二层的一部分）。 实际环境中大多数TCP/IP设备都使用Ethernet V2格式帧。考虑到与其他设备的兼容性，802.3标准并没有如预期那样得到普及。 802.2帧格式 DSAP：目的服务访问点，指出要到达网络层中的协议。类似以太网v2中的类型字段。 SSAP：源服务访问点 控制：用于流量控制等。 以太网类型 无线局域网无线局域网技术 IEEE 802.11 无线局域网 蓝牙，一种小型无线局域网的技术 Zigbee 点到点广域网PPP PPP只有物理层和数据链路层。PPP没有为物理层定义特定的协议，实施者自行选择。在数据链路层，PPP定义了帧的格式，以及用来控制链路和传送用户数据的协议。 根据PPP承载的是数据信息还是控制信息，PPP协议的帧分为3种格式： PPP信息帧、PPP链路控制帧和PPP网络控制帧。 以太网上的PPP（PPP over Ethernet，PPPoE）是一个新的协议，它使用一种发现技术来找出需要连接因特网的主机的以太网地址。在这个地址被发现后，就可以使用PPP会话提供连接。 HDLCHDLC的类型HDLC是一个在同步网上点对点的传输数据，面向比特的数据链路层协议，其帧结构有两种类型： 一种是ISO HDLC帧结构，它由IBM SDLC协议演化过来，采用SDLC的帧格式，支持同步，全双工操作，分为物理层及LLC 两个子层。 一种是Cisco HDLC帧结构，采用SDLC的帧格式，无LLC子层，从而Cisco HDLC对上层数据只进行物理帧封装，没有应答、重传机制，所有的纠错处理由上层协议处理。具有效率高、实现简单的特点，因此，被作为Cisco路由器的默认协议，用于实现Cisco路由器之间的远程连接。 HDLC帧结构 面向比特，标志字段01111110 零比特填充法，防止数据信息干扰标志字段交换广域网ATM异步传输方式(Asynchronous Transfer Mode，ATM）是ATM论坛设计，并被ITU-T采纳的信元中继协议。]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码大全-表驱动法]]></title>
    <url>%2F2017%2F11%2F08%2F%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是表驱动法？表驱动法是一种编程模式 ———— 从表里查找信息而不使用逻辑判断语句。所有能够用逻辑判断语句来选择的事物，都可以使用查表来解决。表驱动法可以在复杂逻辑判断中使用。 使用表驱动法的两个问题怎样从表中查询条目（如何设定表头也就是键）？ 直接访问 索引访问 阶梯访问 应该在表里面存些什么（如何设定表的内容也就是值）？ 数据 描述动作的代码 对实现动作的子程序的引用 直接访问表 直接访问表代替了更为复杂的逻辑控制结构。无需绕圈子就能直接在表里面找到想要的信息。直接访问表主要的问题就是确定查询键值，有以下三种情况： 复制信息从而能够直接使用键值 转换键值以使其能够直接使用 把键值转换提取成独立子程序 索引访问表 索引访问表的使用情景主要是有时候，只用一个简单的数学运算还无法把数据转换成表键值，这类情况的一部分可以通过使用索引访问的方法。索引表不是直接访问，而是经过居间的索引去访问。 索引访问的优点 如果主查询表中的每一条记录都很大，那么创建一个浪费了很多空间的索引数组所用的空间，要比创建一个浪费了很多空间的主查询所有的空间要小得多 即使用了索引后没有节省内存空间，操作位于索引中的记录也要比操作位于主表中的记录更方便廉价 表查询技术在可维护性上具有的普遍优点，编写到表里面的数据比嵌入代码中的数据更容易维护 阶梯访问表 阶梯结构的基本想法是表中的记录对于不同的数据范围有效，而不是对不同的数据点有效。这种方法不像索引结构直接，但是要比索引访问节省空间。 使用阶梯技术时要注意的细节： 留心断点 确认循环能在找出最高一级的区间之后恰当的终止，同时确保正确地处理了两边的边界 考虑使用二分法查找取代顺序查找 阶梯访问大列表时顺序查找可能会比较耗时，可以采用二分的方法来提高效率 考虑用索引访问来取代阶梯技术 阶梯方法中的查找操作可能会比较耗时，如果执行速度更重要，可以考虑使用索引访问取代阶梯访问。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>代码大全</category>
        <category>表驱动法</category>
      </categories>
      <tags>
        <tag>代码大全</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛云回调鉴权问题]]></title>
    <url>%2F2017%2F11%2F06%2F%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%9E%E8%B0%83%E9%89%B4%E6%9D%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述使用七牛云存储遇到了很多坑，比如这个回调鉴权就废了很多时间，特此记录。七牛的回调鉴权主要是通过在请求头上中一个 AUTHORIZATION 的字段中的值来与本地生成的签名生成的值进行比对，如果相同，认证通过。HTTP协议中的 Authorization 请求消息头含有服务器用于验证用户代理身份的凭证，通常会在服务器返回401 Unauthorized 状态码以及WWW-Authenticate 消息头之后在后续请求中发送此消息头。 MDN web docs但是，在业务服务器上使用 $_SERVER[‘HTTP_AUTHORIZATION’] 总是获取不到这个字段的内容，通过提交工单和搜索相关问题发现好像是Apache配置的问题。 解决方案开启Apache配置中的rewrite，然后在入口目录中的.htaccess文件写入下面内容123#Authorization Headers RewriteCond %&#123;HTTP:Authorization&#125; ^(.+)$ RewriteRule .* - [E=HTTP_AUTHORIZATION:%&#123;HTTP:Authorization&#125;]]]></content>
      <tags>
        <tag>七牛云</tag>
        <tag>apache配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO腾讯公益404的设置问题]]></title>
    <url>%2F2017%2F10%2F21%2Fhexo%E8%85%BE%E8%AE%AF%E5%85%AC%E7%9B%8A404%E7%9A%84%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述今天在捣鼓博客时想将404页面跳转到腾讯公益，复制next主题官网上的代码，发现在本地可以正常显示，但是当push到github上的时候，会出现样式文件无法加载的问题，next官网示例代码如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 问题原因在知乎上看到有人说出现该问题的原因是github个人页强制使用https协议，而上面给的代码是http的，因此无法加载样式表。 解决方法NO.1使用购买的域名指向自己的github个人主页，增加CNAME文件，然后调用公益404页面不会出现混合内容那个问题。 NO.2使用如下代码：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" homePageName="返回宝贝回家" homePageUrl="http://www.baobeihuijia.com"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 腾讯寻人空间给出的方法]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
