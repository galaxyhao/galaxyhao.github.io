<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中到底是值传递还是引用传递？]]></title>
    <url>%2F2018%2F06%2F21%2FJava%E4%B8%AD%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[引言关于这个问题，很早之前就碰到过，也查过一些资料，但是网上的说法不统一，导致我一直是似懂非懂的状态，结果今天在刷题的时候又遇到了这个问题，于是我决定梳理一下这块内容，把这个坑给填上。要弄明白这个问题，首先要明确什么是值传递什么是引用传递。值传递：表示方法接收的是调用者提供的值。引用传递：表示方法接收的是调用者提供的变量地址。在Horstman的《JAVA核心技术》上说：“java程序设计语言总是采用值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。” Java基本类型和引用类型的区别存储方式12int num = 10;String str = &quot;hello&quot;; 如图中所示，number属于8种基本类型中的int，所以它的值直接保存在变量中；而str属于引用类型，变量中b保存的是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。 赋值运算的过程12num = 20;str = &quot;java&quot;; 对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收） 调用方法传递参数时发生了什么12345678910111213141516171819202122232425//第一个例子：基本类型void foo(int value) &#123; value = 100;&#125;foo(num); // num 没有被改变//第二个例子：引用类型，但是没有提供改变自身的方法void foo(String text) &#123; text = &quot;windows&quot;;&#125;foo(str); // str 也没有被改变//第三个例子：引用类型，提供了改变自身方法StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder.append(&quot;4&quot;);&#125;foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。//第四个例子：引用类型，提供了改变自身方法，但是不使用，而是使用赋值运算符。StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder = new StringBuilder(&quot;ipad&quot;);&#125;foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。 为什么第三个例子中的sb改变而第四个例子却没有改变呢？下面是第三个例子的执行过程图示在执行了builder.append(“4”)之后，可以看出对象是被直接修改了的，所以函数之外的变量也会被修改而第四个例子中，在执行builder = new StringBuilder(“ipad”)之后，builder变量被指向了一个新的对象，而原来的对象还是存在的，函数外面的变量也是一直指向原来的对象地址 总结在Java中，局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，而对象是存储在堆中的。栈中存储的引用指向堆中的对象，因此只有当我们修改了堆中的对象时，原本函数外指向这个对象的变量才会改变。在C/C++中存在指针，可以使用*p的方式直接访问堆中的对象；而在Java中是不存在指针的，所以要使用点操作符来修改对象。例如上文第三个例子中 builder.append(“4”) 就是让对象调用append()方法，从而修改builder指向的对象。而上文第四个例子中，执行builder = new StringBuilder(“ipad”)修改的是栈中的引用，根本就没有访问堆中的对象，所以无法对方法外的变量造成影响。经过上面的分析，我们终于知道引言中Horstman那句话的意思了，Java方法中传入参数都是拷贝，无法被修改。简单来说，就是在以传值的方式传引用，或者说是传值的方式传地址下面是Java中参数传递的总结： 一个方法不能修改一个基本数据类型的参数 一个方法可以修改一个对象参数的状态 一个方法不能实现让对象参数引用一个新对象 参考资料：知乎 - Intopass和流浪的小鼠的回答独恋幽兰的专栏]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2F2018%2F06%2F16%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[背景介绍字符串匹配是一个很常见的问题。例如：判断文本字符串”BBC ABCDAB ABCDABCDABDE”里面是否包含另一个模式字符串”ABCDABD”。一般的思路很简单，只需要将两个字符串从头开始比较即可（分别使用i、j标识文本字符串和模式字符串的比较位置），若字符相同，则将两个字符串同时向后移一位（i++,j++）；若不同，将文本串串回溯至初始比较位置的下一位（i=i-j+1）,将模式串移动至头部（j=0），直到完全匹配或遍历完整个文本字符串。上面的方法就是暴力匹配算法，但是这种简单粗暴的算法效率上存在着很大的问题，如上面提到的，当i=10,j=6时，字符串会失配，如下图按照暴力匹配算法的话就会将模式串移到头部，文本串移到i=5的位置这样做虽然可行，但是效率很差，因为你要把”搜索位置”（指针i）移到已经比较过的位置，重比一遍。当空格与D不匹配时，其实知道前面六个字符是”ABCDAB”，所以其实是没有必要将文本串回溯到i-j+1的位置的。 KMP算法简述KMP算法是由Donald Knuth、Vaughan Pratt、James H. Morris三人联合发表，作用就是查找文本串中是否包含特定的模式串。它的基本思想就是设法利用已知信息，不把”搜索位置”（指针i）移回已经比较过的位置，而是继续把它向后移，这样就会大大提高匹配效率。下面我简述一下KMP算法的流程， 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），令i++，j++，继续匹配下一个字符；如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 使用之前的例子的话就像下面这样然后我们的问题就变成了模式串P应该向前移动多少位，即next[j]的值是什么。 next数组由上面可知，那么next[j]就表示模式串中第j位失配后下一步需要移动到的位置，实际移动的位数为：j-next[j]。next数组和文本串是无关的，但是怎么求得next数组呢？通过观察上面的例子我们可以看到，失配时移动到的位置k（也就是next[j]）存在着这样一个性质：最前面的k个字符和j之前的最后k个字符是一样的。数学公式表示就像下面这样 P[0 ~ k-1] = P[j-k ~ j-1] 真前缀和真后缀的最大公共长度所以我们要先求模式串中真前缀和真后缀的最大公共长度。下面是关于（真）前缀后缀的定义（在阮一峰大佬的博客中混淆了前/后缀和真前/后缀的概念，看来大佬也有粗心的时候啊）。1234字符串的前缀是指一个字符串全部头部组合，包括最后一个字符；字符串的真前缀是指除了最后一个字符以外，一个字符串的全部尾部组合；字符串的后缀是指一个字符串全部头部组合，包括第一个字符；字符串的真后缀是指除了第一个字符以外，一个字符串的全部尾部组合。 下面是一个字符串“abab”的真前缀真后缀最大公共长度表 模式串 a b a b 真前缀真后缀最大公共长度表 -1 0 0 1 把初始值赋值为-1，可以方便匹配操作。 next数组的求解重头戏终于来了，我们可以用递推的方法来求解next数组，如下图:可以发现，当P[k] == p[j]时，有next[j+1] = k+1.关于这个结论证明如下：已经知道P[0 ~ k-1] == P[j-k ~ j-1]，并且P[k] == p[j]所以P[0 ~ k] == P[j-k ~ j],即next[j+1] = k+1 = next[j]+1. 当P[k] != P[j]的时候呢，如图：执行k=next[k],然后继续比较P[k]与P[j]。不停循环上面的步骤，直到P[k] == P[j]或者k=-1。通过上面的图我们应该知道为什么使k=next[k]，因为匹配不到”ABAAB”这样的串了，但是会有可能匹配到”AB”、”B”这样的串，此过程相当于模式串的自我匹配，所以不断的递归k = next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。这样我们就可以写出计算next数组的代码了1234567891011121314151617181920public int [] getNext(String ps)&#123; char[] p = ps.toCharArray(); int length = p.length; int[] next = new int[length]; next[0] = -1; int j = 0; int k = -1; while (j &lt; length-1)&#123; if (k==-1 || p[j]==p[k])&#123; ++j; ++k; next[j] = k; &#125;else&#123; k = next[k]; &#125; &#125; return next;&#125; 下面是KMP搜索的代码123456789101112131415161718192021public int KMPsearch(String ts,String ps)&#123; char[] t = ts.toCharArray(); char[] p = ps.toCharArray(); int i = 0; int j = 0; int sLength = t.length; int pLength = p.length; int [] next = this.getNext(ps); while (i&lt;sLength &amp;&amp; j&lt;pLength)&#123; if (j==-1 || t[i]==p[j])&#123; i++; j++; &#125;else &#123; j=next[j]; &#125; &#125; if (j == pLength) return i - j; else return -1;&#125; Next数组的优化表面上我们已经完成了所有工作，但是我们忽略了一个问题:比如，如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1，当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。修改后的代码如下：1234567891011121314151617181920212223public int [] getNext(String ps)&#123; char[] p = ps.toCharArray(); int length = p.length; int[] next = new int[length]; next[0] = -1; int j = 0; int k = -1; while (j &lt; length-1)&#123; if (k==-1 || p[j]==p[k])&#123; ++j; ++k; if (p[j] == p[k]) next[j] = next[k]; else next[j] = k; &#125;else&#123; k = next[k]; &#125; &#125; return next;&#125; 参考文章字符串匹配的KMP算法-阮一峰的网络日志从头到尾彻底理解KMP详解KMP算法]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态链表]]></title>
    <url>%2F2018%2F05%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是静态链表静态链表是使用数组描述的链表，在使用C语言中的结构体数组定义时，结构体变量中包括数据data和游标cur。1234567//---------线性表的静态单链表存储结构--------#define MAXSIZE 100typedef struct&#123; ElemType data; int cur;&#125;SLinkList[MAXSIZE]; 对数组的特殊处理 数组的第一个和最后一个元素做特殊处理，他们的data不存放数据。 通常把未使用的数组元素称为备用链表。 数组的第一个元素，即下标为0的那个元素cur就存放备用链表的第一个节点的下标。 数组的最后一个元素，及下标为MAXSIZE-1的cur则存放的第一个有数值的元素的下标，相当于单链表中的头结点作用。 已使用的链表的最后一个元素游标为0。 下标 0 1 2 3 4 5 6 … 999 数据 A C D E … 游标 5 2 3 4 0 6 7 … 1 如上表，下标为0的元素中数据为空，游标为5，指向备用链表的首元素，下标为1,2,3,4的元素数据不为空，游标指向后继元素；最后一个元素下标为999，数据为空，游标指向首链表首元素下表为1。 Java实现相关操作12345678910//初始化静态链表public StaticLink[] init(int length)&#123; StaticLink [] staticLinks = new StaticLink[length]; for (int i=0;i&lt;length-1;i++)&#123; staticLinks[i].cur = i+1; &#125; staticLinks[length-1].cur = 0; return staticLinks;&#125; 12345678//分配链表空间private int mallocStaticLink(StaticLink[] staticLinks)&#123; int i = staticLinks[0].cur; if(i != 0) staticLinks[0].cur = staticLinks[i].cur; return i;&#125; 12345//释放链表空间public void freeStaticLink(StaticLink[] staticLinks,int index)&#123; staticLinks[index].cur = staticLinks[0].cur; staticLinks[0].cur = index;&#125; 123456789101112131415161718192021//向静态链表中插入元素public void insert(StaticLink[] staticLinks,int local,char data)&#123; int length = staticLinks.length; int k = 1; int index = staticLinks[length-1].cur; if(local&lt;1 || local&gt;length-1)&#123; return; &#125; int j = this.mallocStaticLink(staticLinks); if (j != 0)&#123; while (k&lt;local-1)&#123; index = staticLinks[index].cur; //获取插入指定位置的前一个元素的下标 k++; &#125; staticLinks[j].data = data; staticLinks[j].cur = staticLinks[index].cur; staticLinks[index].cur = index; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>静态链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis持久化]]></title>
    <url>%2F2018%2F03%2F27%2FRedis%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[概述大家都知道，Redis是内存数据库，它会把数据都储存在内存当中，可以大幅提高读取速度，但这也出现一个问题，数据易丢失。所以，将内存中的数据持久化处理是很有必要的。Redis共提供了两种持久化的方式，RDB全量写入方式和AOF增量写入方式。 RDB全量写入方式RDB就是将整个redis中的内容dump下来，做一个快照。RDB是redis默认的持久化方式。 相关配置123456save 900 1save 300 10save 60 10000rdbchecksum yes #是否校验rdb文件dbfilename &quot;redis-6379.rdb&quot; #持久化文件名称dir &quot;/data/dbs/redis/6379&quot; #持久化数据文件存放的路径 前三行是触发RDB的条件，意思是当900秒中redis有一条数据写入就会进行RDB操作，二三行同上。 相关命令savesave是以阻塞的方式将redis的数据写入rdb文件，是redis主进程进行此项操作，直到该文件创建完毕的这段时间内redis将不能处理任何命令请求。 bgsave执行bgsave操作时，redis主进程会先fork一个子进程，由子进程将数据写入rdb文件。这种方式耗费的资源比save要多。 AOF增量写入方式AOF类似于日志，会将对redis的所有操作写入aof文件中，方便数据的恢复。 相关配置123456dir &quot;/data/dbs/redis/6379&quot; #AOF文件存放目录appendonly yes #开启AOF持久化，默认关闭appendfilename &quot;redis-6379.aof&quot; #AOF文件名称appendfsync no #AOF持久化策略auto-aof-rewrite-percentage 100 #触发AOF文件重写的条件，增量百分比auto-aof-rewrite-min-size 64mb #触发AOF文件重写的条件，文件大小 三种触发持久化的策略第四行是AOF持久化的策略，AOF共有三种持久化策略，分别为always、everysec 、no。 always策略是每提交一个修改命令都调用fsync刷新到AOF文件 everysec策略是每秒钟都调用fsync将一秒内的修改刷新至AOF文件，但可能会丢失一秒以内的数据 noc策略是依靠OS进行刷新，redis不主动刷新AOF AOF文件重写我们知道，AOF持久化会记录redis的每一条修改指令，所以AOF文件会变得非常非常的大。因此redis实现了AOF文件重写的方法，就是会合并对相同key的操作。例如：key的值为1， INCR key操作进行了5次，AOF重写后变为SET key 6。查了相关的资料，发现这个“重写”的说法是有歧义的。AOF重写并不是对原有AOF文件进行任何写入和读取，而是根据目前的结果来用相应的语句实现。讲了这么多，redis配置文件中有关重写的配置有auto-aof-rewrite-percentage和auto-aof-rewrite-min-size。第一个的意思是达到文件增量的百分比时触发重写，默认为100%；第二个是文件大小达到指定大小触发重写，默认为64mb。 两种持久化方式的比较 RDB AOF 恢复优先级 低 高 文件体积 小 大 恢复速度 快 慢 数据安全性 易丢数据 根据策略决定 轻重 重 轻]]></content>
      <categories>
        <category>redis学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos下配置Supervisor]]></title>
    <url>%2F2018%2F03%2F26%2Fcentos%E4%B8%8B%E9%85%8D%E7%BD%AESupervisor%2F</url>
    <content type="text"><![CDATA[背景最近项目中需要用到Supervisor来保证进程能持续运行，Supervisor官网中是这样介绍的Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。 配置过程安装服务器环境为CentOS7.2，使用wget命令下载源码安装，安装过程中可能会需要几个依赖的包，根据提示自行下载即可。 supervisor的配置安装完成后，使用echo_supervisord_conf打印出一个配置文件的样本，样本如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254[unix_http_server] file=/tmp/supervisor.sock ; socket文件的路径，supervisorctl用XML_RPC和supervisord通信就是通过它进行 的。如果不设置的话，supervisorctl也就不能用了 不设置的话，默认为none。 非必须设置 ;chmod=0700 ; 这个简单，就是修改上面的那个socket文件的权限为0700 不设置的话，默认为0700。 非必须设置;chown=nobody:nogroup ; 这个一样，修改上面的那个socket文件的属组为user.group 不设置的话，默认为启动supervisord进程的用户及属组。非必须设置;username=user ; 使用supervisorctl连接的时候，认证的用户 不设置的话，默认为不需要用户。 非必须设置;password=123 ; 和上面的用户名对应的密码，可以直接使用明码，也可以使用SHA加密 如：&#123;SHA&#125;82ab876d1387bfafe46cc1c8a2ef074eae50cb1d 默认不设置。。。非必须设置;[inet_http_server] ; 侦听在TCP上的socket，Web Server和远程的supervisorctl都要用到他 不设置的话，默认为不开启。非必须设置;port=127.0.0.1:9001 ; 这个是侦听的IP和端口，侦听所有IP用 :9001或*:9001。 这个必须设置，只要上面的[inet_http_server]开启了，就必须设置它;username=user ; 这个和上面的uinx_http_server一个样。非必须设置;password=123 ; 这个也一个样。非必须设置[supervisord] ;这个主要是定义supervisord这个服务端进程的一些参数的 这个必须设置，不设置，supervisor就不用干活了logfile=/tmp/supervisord.log ; 这个是supervisord这个主进程的日志路径，注意和子进程的日志不搭嘎。 默认路径$CWD/supervisord.log，$CWD是当前目录。。非必须设置logfile_maxbytes=50MB ; 这个是上面那个日志文件的最大的大小，当超过50M的时候，会生成一个新的日 志文件。当设置为0时，表示不限制文件大小 默认值是50M，非必须设置。 logfile_backups=10 ; 日志文件保持的数量，上面的日志文件大于50M时，就会生成一个新文件。文件 数量大于10时，最初的老文件被新文件覆盖，文件数量将保持为10 当设置为0时，表示不限制文件的数量。 默认情况下为10。。。非必须设置loglevel=info ; 日志级别，有critical, error, warn, info, debug, trace, or blather等 默认为info。。。非必须设置项pidfile=/tmp/supervisord.pid ; supervisord的pid文件路径。 默认为$CWD/supervisord.pid。。。非必须设置nodaemon=false ; 如果是true，supervisord进程将在前台运行 默认为false，也就是后台以守护进程运行。。。非必须设置minfds=1024 ; 这个是最少系统空闲的文件描述符，低于这个值supervisor将不会启动。 系统的文件描述符在这里设置cat /proc/sys/fs/file-max 默认情况下为1024。。。非必须设置minprocs=200 ; 最小可用的进程描述符，低于这个值supervisor也将不会正常启动。 ulimit -u这个命令，可以查看linux下面用户的最大进程数 默认为200。。。非必须设置;umask=022 ; 进程创建文件的掩码 默认为022。。非必须设置项;user=chrism ; 这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。 我这里面设置的这个用户，也可以对supervisord进行管理 默认情况是不设置。。。非必须设置项;identifier=supervisor ; 这个参数是supervisord的标识符，主要是给XML_RPC用的。当你有多个 supervisor的时候，而且想调用XML_RPC统一管理，就需要为每个 supervisor设置不同的标识符了 默认是supervisord。。。非必需设置;directory=/tmp ; 这个参数是当supervisord作为守护进程运行的时候，设置这个参数的话，启动 supervisord进程之前，会先切换到这个目录 默认不设置。。。非必须设置;nocleanup=true ; 这个参数当为false的时候，会在supervisord进程启动的时候，把以前子进程 产生的日志文件(路径为AUTO的情况下)清除掉。有时候咱们想要看历史日志，当 然不想日志被清除了。所以可以设置为true 默认是false，有调试需求的同学可以设置为true。。。非必须设置;childlogdir=/tmp ; 当子进程日志路径为AUTO的时候，子进程日志文件的存放路径。 默认路径是这个东西，执行下面的这个命令看看就OK了，处理的东西就默认路径 python -c &quot;import tempfile;print tempfile.gettempdir()&quot; 非必须设置;environment=KEY=&quot;value&quot; ; 这个是用来设置环境变量的，supervisord在linux中启动默认继承了linux的 环境变量，在这里可以设置supervisord进程特有的其他环境变量。 supervisord启动子进程时，子进程会拷贝父进程的内存空间内容。 所以设置的 这些环境变量也会被子进程继承。 小例子：environment=name=&quot;haha&quot;,age=&quot;hehe&quot; 默认为不设置。。。非必须设置;strip_ansi=false ; 这个选项如果设置为true，会清除子进程日志中的所有ANSI 序列。什么是ANSI 序列呢？就是我们的\n,\t这些东西。 默认为false。。。非必须设置; the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor] ;这个选项是给XML_RPC用的，当然你如果想使用supervisord或者web server 这 个选项必须要开启的supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface [supervisorctl] ;这个主要是针对supervisorctl的一些配置 serverurl=unix:///tmp/supervisor.sock ; 这个是supervisorctl本地连接supervisord的时候，本地UNIX socket 路径，注意这个是和前面的[unix_http_server]对应的 默认值就是unix:///tmp/supervisor.sock。。非必须设置;serverurl=http://127.0.0.1:9001 ; 这个是supervisorctl远程连接supervisord的时候，用到的TCP socket路径 注意这个和前面的[inet_http_server]对应 默认就是http://127.0.0.1:9001。。。非必须项 ;username=chris ; 用户名 默认空。。非必须设置;password=123 ; 密码 默认空。。非必须设置;prompt=mysupervisor ; 输入用户名密码时候的提示符 默认supervisor。。非必须设置;history_file=~/.sc_history ; 这个参数和shell中的history类似，我们可以用上下键来查找前面执行过的命令 默认是no file的。。所以我们想要有这种功能，必须指定一个文件。。。非 必须设置; The below sample program section shows all possible program subsection values,; create one or more &apos;real&apos; program: sections to be able to control them under; supervisor.;[program:theprogramname] ;这个就是咱们要管理的子进程了，&quot;:&quot;后面的是名字，最好别乱写和实际进程 有点关联最好。这样的program我们可以设置一个或多个，一个program就是 要被管理的一个进程;command=/bin/cat ; 这个就是我们的要启动进程的命令路径了，可以带参数 例子：/home/test.py -a &apos;hehe&apos; 有一点需要注意的是，我们的command只能是那种在终端运行的进程，不能是 守护进程。这个想想也知道了，比如说command=service httpd start。 httpd这个进程被linux的service管理了，我们的supervisor再去启动这个命令 这已经不是严格意义的子进程了。 这个是个必须设置的项;process_name=%(program_name)s ; 这个是进程名，如果我们下面的numprocs参数为1的话，就不用管这个参数 了，它默认值%(program_name)s也就是上面的那个program冒号后面的名字， 但是如果numprocs为多个的话，那就不能这么干了。想想也知道，不可能每个 进程都用同一个进程名吧。 ;numprocs=1 ; 启动进程的数目。当不为1时，就是进程池的概念，注意process_name的设置 默认为1 。。非必须设置;directory=/tmp ; 进程运行前，会前切换到这个目录 默认不设置。。。非必须设置;umask=022 ; 进程掩码，默认none，非必须;priority=999 ; 子进程启动关闭优先级，优先级低的，最先启动，关闭的时候最后关闭 默认值为999 。。非必须设置;autostart=true ; 如果是true的话，子进程将在supervisord启动后被自动启动 默认就是true 。。非必须设置;autorestart=unexpected ; 这个是设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected 和true。如果为false的时候，无论什么情况下，都不会被重新启动， 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退 出码的时候，才会被自动重启。当为true的时候，只要子进程挂掉，将会被无 条件的重启;startsecs=1 ; 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启 动成功了 默认值为1 。。非必须设置;startretries=3 ; 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把 此进程的状态置为FAIL 默认值为3 。。非必须设置;exitcodes=0,2 ; 注意和上面的的autorestart=unexpected对应。。exitcodes里面的定义的 退出码是expected的。;stopsignal=QUIT ; 进程停止信号，可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2等信号 默认为TERM 。。当用设定的信号去干掉进程，退出码会被认为是expected 非必须设置;stopwaitsecs=10 ; 这个是当我们向子进程发送stopsignal信号后，到系统返回信息 给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该 子进程发送一个强制kill的信号。 默认为10秒。。非必须设置;stopasgroup=false ; 这个东西主要用于，supervisord管理的子进程，这个子进程本身还有 子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程 有可能会变成孤儿进程。所以咱们可以设置可个选项，把整个该子进程的 整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。 需要注意的是，该选项发送的是stop信号 默认为false。。非必须设置。。;killasgroup=false ; 这个和上面的stopasgroup类似，不过发送的是kill信号;user=chrism ; 如果supervisord是root启动，我们在这里设置这个非root用户，可以用来 管理该program 默认不设置。。。非必须设置项;redirect_stderr=true ; 如果为true，则stderr的日志会被写入stdout日志文件中 默认为false，非必须设置;stdout_logfile=/a/path ; 子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项。 设置为none的话，将没有日志产生。设置为AUTO的话，将随机找一个地方 生成日志文件，而且当supervisord重新启动的时候，以前的日志文件会被 清空。当 redirect_stderr=true的时候，sterr也会写进这个日志文件;stdout_logfile_maxbytes=1MB ; 日志文件最大大小，和[supervisord]中定义的一样。默认为50;stdout_logfile_backups=10 ; 和[supervisord]定义的一样。默认10;stdout_capture_maxbytes=1MB ; 这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout 发送信息，而supervisor可以根据信息，发送相应的event。 默认为0，为0的时候表达关闭管道。。。非必须项;stdout_events_enabled=false ; 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将 触发supervisord发送PROCESS_LOG_STDOUT类型的event 默认为false。。。非必须设置;stderr_logfile=/a/path ; 这个东西是设置stderr写的日志路径，当redirect_stderr=true。这个就不用 设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中 默认为AUTO，也就是随便找个地存，supervisord重启被清空。。非必须设置;stderr_logfile_maxbytes=1MB ; 这个出现好几次了，就不重复了;stderr_logfile_backups=10 ; 这个也是;stderr_capture_maxbytes=1MB ; 这个一样，和stdout_capture一样。 默认为0，关闭状态;stderr_events_enabled=false ; 这个也是一样，默认为false;environment=A=&quot;1&quot;,B=&quot;2&quot; ; 这个是该子进程的环境变量，和别的子进程是不共享的;serverurl=AUTO ; ; The below sample eventlistener section shows all possible; eventlistener subsection values, create one or more &apos;real&apos;; eventlistener: sections to be able to handle event notifications; sent by supervisor.;[eventlistener:theeventlistenername] ;这个东西其实和program的地位是一样的，也是suopervisor启动的子进 程，不过它干的活是订阅supervisord发送的event。他的名字就叫 listener了。我们可以在listener里面做一系列处理，比如报警等等 楼主这两天干的活，就是弄的这玩意;command=/bin/eventlistener ; 这个和上面的program一样，表示listener的可执行文件的路径;process_name=%(program_name)s ; 这个也一样，进程名，当下面的numprocs为多个的时候，才需要。否则默认就 OK了;numprocs=1 ; 相同的listener启动的个数;events=EVENT ; event事件的类型，也就是说，只有写在这个地方的事件类型。才会被发送 ;buffer_size=10 ; 这个是event队列缓存大小，单位不太清楚，楼主猜测应该是个吧。当buffer 超过10的时候，最旧的event将会被清除，并把新的event放进去。 默认值为10。。非必须选项;directory=/tmp ; 进程执行前，会切换到这个目录下执行 默认为不切换。。。非必须;umask=022 ; 淹没，默认为none，不说了;priority=-1 ; 启动优先级，默认-1，也不扯了;autostart=true ; 是否随supervisord启动一起启动，默认true;autorestart=unexpected ; 是否自动重启，和program一个样，分true,false,unexpected等，注意 unexpected和exitcodes的关系;startsecs=1 ; 也是一样，进程启动后跑了几秒钟，才被认定为成功启动，默认1;startretries=3 ; 失败最大尝试次数，默认3;exitcodes=0,2 ; 期望或者说预料中的进程退出码，;stopsignal=QUIT ; 干掉进程的信号，默认为TERM，比如设置为QUIT，那么如果QUIT来干这个进程 那么会被认为是正常维护，退出码也被认为是expected中的;stopwaitsecs=10 ; max num secs to wait b4 SIGKILL (default 10);stopasgroup=false ; send stop signal to the UNIX process group (default false);killasgroup=false ; SIGKILL the UNIX process group (def false);user=chrism ;设置普通用户，可以用来管理该listener进程。 默认为空。。非必须设置;redirect_stderr=true ; 为true的话，stderr的log会并入stdout的log里面 默认为false。。。非必须设置;stdout_logfile=/a/path ; 这个不说了，好几遍了;stdout_logfile_maxbytes=1MB ; 这个也是;stdout_logfile_backups=10 ; 这个也是;stdout_events_enabled=false ; 这个其实是错的，listener是不能发送event;stderr_logfile=/a/path ; 这个也是;stderr_logfile_maxbytes=1MB ; 这个也是;stderr_logfile_backups ; 这个不说了;stderr_events_enabled=false ; 这个也是错的，listener不能发送event;environment=A=&quot;1&quot;,B=&quot;2&quot; ; 这个是该子进程的环境变量 默认为空。。。非必须设置;serverurl=AUTO ; override serverurl computation (childutils); The below sample group section shows all possible group values,; create one or more &apos;real&apos; group: sections to create &quot;heterogeneous&quot;; process groups.;[group:thegroupname] ;这个东西就是给programs分组，划分到组里面的program。我们就不用一个一个去操作了 我们可以对组名进行统一的操作。 注意：program被划分到组里面之后，就相当于原来 的配置从supervisor的配置文件里消失了。。。supervisor只会对组进行管理，而不再 会对组里面的单个program进行管理了;programs=progname1,progname2 ; 组成员，用逗号分开 这个是个必须的设置项;priority=999 ; 优先级，相对于组和组之间说的 默认999。。非必须选项; The [include] section can just contain the &quot;files&quot; setting. This; setting can list multiple files (separated by whitespace or; newlines). It can also contain wildcards. The filenames are; interpreted as relative to this file. Included files *cannot*; include files themselves.;[include] ;这个东西挺有用的，当我们要管理的进程很多的时候，写在一个文件里面 就有点大了。我们可以把配置信息写到多个文件中，然后include过来;files = relative/directory/*.ini 以上配置中[unix_http_server]下的file=/tmp/supervisor.sock最好改成/var/supervisor.sock,以防系统自动清除，其他配置中含有/tmp的最好也改一下，原因同上。还有一个问题就是如果想要使用web界面查看supervisor需要开启[inet_http_server]。 进程配置12345678910111213[program:getcash]directory = /home/wwwroot/xiaotx/domain/ ; 程序的启动目录command = php think queue:work --queue get_cash --daemon --sleep 1800 --memory 128 ; 启动命令autostart = true ; 在 supervisord 启动的时候也自动启动startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true ; 程序异常退出后自动重启startretries = 3 ; 启动失败自动重试次数，默认是 3user = www ; 用哪个用户启动redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile = /data/logs/getcash.log]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中精度丢失的问题]]></title>
    <url>%2F2018%2F03%2F20%2FPHP%E4%B8%AD%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述在做微信支付时，需要将浮点数（以元为单位）转换为整数（以分为单位），结果出现了匪夷所思的问题，代码如下123$num = 9.7*100;echo $num; //结果为970echo (int)$num; //结果为969 问题原因突然想到之前在学习JavaScript的时候看到IEEE754格式，浮点数操作时会出现精度丢失的问题。去看了一下官网手册，果然是这个原因。 浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754 双精度格式，则由于取整而导致的最大相对误差为 1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运算时的误差传递。此外，以十进制能够精确表示的有理数如 0.1 或 0.7，无论有多少尾数都不能被内部所使用的二进制精确表示，因此不能在不丢失一点点精度的情况下转换为二进制的格式。这就会造成混乱的结果：例如，floor((0.1+0.7)*10) 通常会返回 7 而不是预期中的 8，因为该结果内部的表示其实是类似 7.9999999999999991118…。所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数。 解决方案 采用php中的round()函数对浮点数进行四舍五入，然后进行取整。 1(int)round((0.1+0.7)*10) 先将浮点数转换为字符串，然后转换为整数 1(int)(string)((0.1+0.7)*10) 这篇文章详细的介绍了出现精度丢失的原因，直接上链接http://justjavac.com/codepuzzle/2012/11/11/codepuzzle-float-who-stole-your-accuracy.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延迟消息队列-时间轮]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%97%B6%E9%97%B4%E8%BD%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>系统架构</tag>
        <tag>延迟消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于订单状态自动更新的思考和实现]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%85%B3%E4%BA%8E%E8%AE%A2%E5%8D%95%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[问题描述（背景）在所有电商交易平台中都会遇到订单状态需要自动流转的问题，比如用户下单未付款30分钟后自动关闭订单、在商家发货15天之后如用户未确认收货自动将订单变为收货状态等等。我查找了一些相关的资料，发现有很多解决方案，下面将列出几个我认为比较经典的方案。 解决方案1.被动更新这是最笨也是最麻烦的办法，就是在用户每一次操作时，都需要进行一个订单状态及时间的判断，假设用户一直没有对用户进行操作，那么订单的状态永远不会被更新。 缺点：每次订单操作前都会对订单状态进行判断，假设订单数量很大时，会浪费大量资源；而且随着订单操作方法越来越多，会变得非常不好管理。 2.轮询这也是一个比较直接的思路，可以利用Linux中的cron定时任务来定时扫订单表，取出所有需要更新状态的订单进行更新操作。 缺点：第一个是轮序的时间粒度很难把握，粒度大的话会导致很多订单状态更新的不够及时，力度小的话或耗费大量的资源；另一个就是随着时间的增加，数据库中的订单数量会越来越多，全表扫描会占用数据库大量资源。 3.利用redis做延迟消息队列（改进方法2中的不足）由于最近学了redis，就在思考怎么使用redis来解决这个问题，毕竟相同配置下的redis的QPS/TPS要远远大于mysql的，而且也不能像方法2中的那样毫无区分的进行全表扫描，那样不但效率低而且会浪费大量的资源。能不能只把有可能会进行自动更新状态的订单放到redis中呢，其实这样就是一个延迟消息队列的雏形了。那么还有没有需要改进的地方呢，上面说到轮询的时间粒度是很难把握的，那能不能用动态的时间扫一个队列呢？我们知道redis中有一个叫做score set(有序集合)的数据类型，我们可以把要更新的时间写到有序集合的score中，一个有序集合按照由小到大排列，这样的话每个队列的第一个元素中的score就决定了我们timer定时器的休眠时间。 下面总结一下改进的地方： 使用消息队列的结构替代方法2中的全表扫描，更多的节省了资源，提高了效率 根据队列首个元素的延迟时间动态规划定时器的扫描间隔，避免无必要的扫描 能够灵活的添加、删除延迟任务]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>系统架构</tag>
        <tag>延迟消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis中的pipline]]></title>
    <url>%2F2018%2F03%2F07%2FRedis%E4%B8%AD%E7%9A%84pipline%2F</url>
    <content type="text"><![CDATA[什么是流水线 流水线就是将批量命令打包，通过一次网络传输进行操作执行的过程。 批量网络命令通信：n次时间 = n次网络时间 + n次执行时间 流水线命令通信：n次时间 = 1次网络时间 + n次执行时间 主要是为了解决命令在网络传输中耗时长的问题 与原生操作的对比原生批量操作命令如mset,mset等是原子的，而pipline不是原子操作。]]></content>
      <categories>
        <category>redis学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis慢查询]]></title>
    <url>%2F2018%2F03%2F07%2FRedis%E6%85%A2%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[redis的生命周期 redis的慢查询发生在第三个阶段 关于慢查询的两个配置slowlog-max-len 储存慢查询信息的队列长度 在redis中，慢查询语句存储在一个固定长度的先进先出队列当中，它们被保存在内存当中。 slowlog-log-slower-than 慢查询阈值 单位是微秒 slowlog-log-slower-than=0,记录所有命令 slowlog-log-slower-than&lt;0,不记录慢查询 慢查询命令 slowlog get[n]: 获取慢查询队列，n为获取的数量 slowlog len: 获取慢查询队列的长度 slow reset: 清空慢查询队列 配置慢查询注意事项 slowlog-max-len不要设置过大，默认10ms，通常1ms slowlog-log-slower-than不要设置过小，通常1000左右 理解生命周期 定期持久化慢查询]]></content>
      <categories>
        <category>redis学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis的特性]]></title>
    <url>%2F2018%2F03%2F05%2FRedis%E7%9A%84%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[速度快 数据存在内存（主要原因）; 使用C语言编写; 采用单线程线程模型 持久化（断电不丢失）Redis所有数据保存在内存当中，对数据的更新将异步的保存在磁盘中。 多种数据机构 主要数据结构 字符串 (String) 哈希 (Hash Tables) 列表（Linked Lists） 集合 (Sets) 有序集合 (Sorted Sets) 衍生数据结构 位图（BitMaps） 超小内存唯一值计数（HyperLogLog） 地理信息定位（GEO） 支持多种客户端语言支持像java、php、python等多种主流语言 功能丰富 发布订阅 Lua脚本 简单事务功能 pipeline “简单” 不依赖外部库; 单线程编程模型，开发容易 主从复制高可用、分布式 Redis-Sentinel(v2.8)支持高可用; Redis-Cluster(v3.0)支持分布式]]></content>
      <categories>
        <category>redis学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议-ICMP]]></title>
    <url>%2F2018%2F01%2F16%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-ICMP%2F</url>
    <content type="text"><![CDATA[ICMP引言产生背景ICMP为了补偿IP的缺陷而设计的。ICMP提供路由器报告错误，提供主机测试目的端是否能到达。 概述ICMP是Internet控制消息协议的缩写，属于网络层协议。ICMP只能报告差错，不能纠正差错。 ICMP的封装 ICMP报文不直接传给链路层，而是封装成IP数据报，再传给数据链路层。 ICMP总是把差错报文给最初的数据源，而不是通知中间服务器。 ICMP差错和查询报文 ICMPv6版本4和版本6的比较 在版本4中的ICMP，ARP和IGMP合并成一个协议ICMPv6。]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议-底层技术]]></title>
    <url>%2F2018%2F01%2F15%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[有线局域网以太网（Ethernet） 以太网发送的分组称为帧，每个帧含有7个字段：前同步码、帧首定界符、目标地址、源地址、长度/类型、数据和填充、FCS(CRC)。 以太网不提供任何机制来确定收到的帧，所以以太网是一种被称为不可靠的媒体。 以太网帧长度最小为64bytes(512bits)，最大为1518bytes(12,144bits)。 802.3和802.2 IEEE 正式的标准，它由Ethernet V2发展而来。它将Ethernet V2帧头的协议类型字段替换为帧长度字段(取值为0x0000-0x05dc（十进制1500）)；并加入802.2 LLC头用以标志上层协议。 以太网提供的服务对应于OSI模型的第一层和第二层，而802.3提供的服务对应于OSI模型的第一层和第二层的信道访问部分（即第二层的一部分）。 实际环境中大多数TCP/IP设备都使用Ethernet V2格式帧。考虑到与其他设备的兼容性，802.3标准并没有如预期那样得到普及。 802.2帧格式 DSAP：目的服务访问点，指出要到达网络层中的协议。类似以太网v2中的类型字段。 SSAP：源服务访问点 控制：用于流量控制等。 以太网类型 无线局域网无线局域网技术 IEEE 802.11 无线局域网 蓝牙，一种小型无线局域网的技术 Zigbee 点到点广域网PPP PPP只有物理层和数据链路层。PPP没有为物理层定义特定的协议，实施者自行选择。在数据链路层，PPP定义了帧的格式，以及用来控制链路和传送用户数据的协议。 根据PPP承载的是数据信息还是控制信息，PPP协议的帧分为3种格式： PPP信息帧、PPP链路控制帧和PPP网络控制帧。 以太网上的PPP（PPP over Ethernet，PPPoE）是一个新的协议，它使用一种发现技术来找出需要连接因特网的主机的以太网地址。在这个地址被发现后，就可以使用PPP会话提供连接。 HDLCHDLC的类型HDLC是一个在同步网上点对点的传输数据，面向比特的数据链路层协议，其帧结构有两种类型： 一种是ISO HDLC帧结构，它由IBM SDLC协议演化过来，采用SDLC的帧格式，支持同步，全双工操作，分为物理层及LLC 两个子层。 一种是Cisco HDLC帧结构，采用SDLC的帧格式，无LLC子层，从而Cisco HDLC对上层数据只进行物理帧封装，没有应答、重传机制，所有的纠错处理由上层协议处理。具有效率高、实现简单的特点，因此，被作为Cisco路由器的默认协议，用于实现Cisco路由器之间的远程连接。 HDLC帧结构 面向比特，标志字段01111110 零比特填充法，防止数据信息干扰标志字段交换广域网ATM异步传输方式(Asynchronous Transfer Mode，ATM）是ATM论坛设计，并被ITU-T采纳的信元中继协议。]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码大全-表驱动法]]></title>
    <url>%2F2017%2F11%2F08%2F%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是表驱动法？表驱动法是一种编程模式 ———— 从表里查找信息而不使用逻辑判断语句。所有能够用逻辑判断语句来选择的事物，都可以使用查表来解决。表驱动法可以在复杂逻辑判断中使用。 使用表驱动法的两个问题怎样从表中查询条目（如何设定表头也就是键）？ 直接访问 索引访问 阶梯访问 应该在表里面存些什么（如何设定表的内容也就是值）？ 数据 描述动作的代码 对实现动作的子程序的引用 直接访问表 直接访问表代替了更为复杂的逻辑控制结构。无需绕圈子就能直接在表里面找到想要的信息。直接访问表主要的问题就是确定查询键值，有以下三种情况： 复制信息从而能够直接使用键值 转换键值以使其能够直接使用 把键值转换提取成独立子程序 索引访问表 索引访问表的使用情景主要是有时候，只用一个简单的数学运算还无法把数据转换成表键值，这类情况的一部分可以通过使用索引访问的方法。索引表不是直接访问，而是经过居间的索引去访问。 索引访问的优点 如果主查询表中的每一条记录都很大，那么创建一个浪费了很多空间的索引数组所用的空间，要比创建一个浪费了很多空间的主查询所有的空间要小得多 即使用了索引后没有节省内存空间，操作位于索引中的记录也要比操作位于主表中的记录更方便廉价 表查询技术在可维护性上具有的普遍优点，编写到表里面的数据比嵌入代码中的数据更容易维护 阶梯访问表 阶梯结构的基本想法是表中的记录对于不同的数据范围有效，而不是对不同的数据点有效。这种方法不像索引结构直接，但是要比索引访问节省空间。 使用阶梯技术时要注意的细节： 留心断点 确认循环能在找出最高一级的区间之后恰当的终止，同时确保正确地处理了两边的边界 考虑使用二分法查找取代顺序查找 阶梯访问大列表时顺序查找可能会比较耗时，可以采用二分的方法来提高效率 考虑用索引访问来取代阶梯技术 阶梯方法中的查找操作可能会比较耗时，如果执行速度更重要，可以考虑使用索引访问取代阶梯访问。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>代码大全</category>
        <category>表驱动法</category>
      </categories>
      <tags>
        <tag>代码大全</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛云回调鉴权问题]]></title>
    <url>%2F2017%2F11%2F06%2F%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%9E%E8%B0%83%E9%89%B4%E6%9D%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述使用七牛云存储遇到了很多坑，比如这个回调鉴权就废了很多时间，特此记录。七牛的回调鉴权主要是通过在请求头上中一个 AUTHORIZATION 的字段中的值来与本地生成的签名生成的值进行比对，如果相同，认证通过。HTTP协议中的 Authorization 请求消息头含有服务器用于验证用户代理身份的凭证，通常会在服务器返回401 Unauthorized 状态码以及WWW-Authenticate 消息头之后在后续请求中发送此消息头。 MDN web docs但是，在业务服务器上使用 $_SERVER[‘HTTP_AUTHORIZATION’] 总是获取不到这个字段的内容，通过提交工单和搜索相关问题发现好像是Apache配置的问题。 解决方案开启Apache配置中的rewrite，然后在入口目录中的.htaccess文件写入下面内容123#Authorization Headers RewriteCond %&#123;HTTP:Authorization&#125; ^(.+)$ RewriteRule .* - [E=HTTP_AUTHORIZATION:%&#123;HTTP:Authorization&#125;]]]></content>
      <tags>
        <tag>七牛云</tag>
        <tag>apache配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO腾讯公益404的设置问题]]></title>
    <url>%2F2017%2F10%2F21%2Fhexo%E8%85%BE%E8%AE%AF%E5%85%AC%E7%9B%8A404%E7%9A%84%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述今天在捣鼓博客时想将404页面跳转到腾讯公益，复制next主题官网上的代码，发现在本地可以正常显示，但是当push到github上的时候，会出现样式文件无法加载的问题，next官网示例代码如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 问题原因在知乎上看到有人说出现该问题的原因是github个人页强制使用https协议，而上面给的代码是http的，因此无法加载样式表。 解决方法NO.1使用购买的域名指向自己的github个人主页，增加CNAME文件，然后调用公益404页面不会出现混合内容那个问题。 NO.2使用如下代码：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" homePageName="返回宝贝回家" homePageUrl="http://www.baobeihuijia.com"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 腾讯寻人空间给出的方法]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
